!function(e){var t={};function i(s){if(t[s])return t[s].exports;var a=t[s]={i:s,l:!1,exports:{}};return e[s].call(a.exports,a,a.exports,i),a.l=!0,a.exports}i.m=e,i.c=t,i.d=function(e,t,s){i.o(e,t)||Object.defineProperty(e,t,{configurable:!1,enumerable:!0,get:s})},i.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return i.d(t,"a",t),t},i.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},i.p="",i(i.s=5)}([function(e,t,i){function s(e){const t=Math.floor(Math.random()*e.length),i=e[t];return e.splice(t,1),i}function a(e,t,i){this.width=e,this.height=t,this.cellSize=i,this.array=new Array(e);for(let i=0;i<e;i++)this.array[i]=new Array(t)}function r(e,t){const i=t*(Math.random()+1),s=6.283185307178*Math.random(),a=e.x+i*Math.cos(s),r=e.y+i*Math.sin(s);return new THREE.Vector2(a,r)}i(3),a.prototype={constructor:a,t:function(e){const t=Math.floor(e.x/this.cellSize),i=Math.floor(e.y/this.cellSize);this.array[t][i]=e},h:function(e,t){const i=Math.floor(e.x/this.cellSize),s=Math.floor(e.y/this.cellSize);for(let a=i-5;a<i+5;a++)for(let i=s-5;i<s+5;i++)if(a>=0&&a<this.width&&i>=0&&i<this.height){const s=this.array[a][i];let r=1e10;if(void 0!==s&&(r=s.distanceTo(e)),r<t)return!0}return!1}},e.exports=(PIXOTRON.lerpDistribution=function(e,t,i){return(t=t||.47)*(1-e)+(i=i||7)*e},PIXOTRON.uniformDistribution=function(){return 1},PIXOTRON.cosineDistribution=function(e){const t=e*Math.PI/2,i=Math.cos(t);return.47*(1-i)+7*i},PIXOTRON.generateQuasiRandomPoints=function(e,t,i,o){i=i||PIXOTRON.uniformDistribution,o=o||PIXOTRON.insideCircle,t<0&&(t=Math.sqrt(e)/e);const n=[],l=[],h=t/Math.sqrt(2),u=new a(Math.ceil(1/h),Math.ceil(1/h),h),c=new THREE.Vector2(.5,.5);let d=!1;do{c.x=Math.random(),c.y=Math.random(),d=o(c.x,c.y)}while(!d);for(l.push(c),n.push(c),u.t(c);0!==l.length&&n.length<e;){const e=s(l);for(let s=0;s<30;s++){const s=e.x-.5,a=e.y-.5,h=i(Math.sqrt(s*s+a*a)),c=r(e,h*t);!o(c.x,c.y)||u.h(c,h*t)||(l.push(c),n.push(c),u.t(c))}}return n})},function(e,t,i){i(11),e.exports=PIXOTRON.QualityAdapter=class{constructor(e){this.u=e,this.currentQualitySetting=null,this.previousQualitySetting=null,this.v=!1,this.R=!1,this.T=!1}enable(){}disable(){}getCurrentQualitySetting(){return this.currentQualitySetting}update(){}onQualityChange(e){this.qualityChangedCallBack!==e&&(this.qualityChangedCallBack=e)}O(e){this.N(e,this.currentQualitySetting)?this.T:(this.previousQualitySetting=this.currentQualitySetting,this.currentQualitySetting=e,this.previousQualitySetting&&this.previousQualitySetting.exit(),this.currentQualitySetting.enter(),this.currentQualitySetting.change(this.u),this.qualityChangedCallBack&&this.qualityChangedCallBack(this.currentQualitySetting,this.previousQualitySetting))}N(e,t){return!(!e||!t)&&e.getQuality()===t.getQuality()}}},function(e,t){e.exports=PIXOTRON.SmoothTransitionAOShader={uniforms:{saoAccumulationBuffer:{value:null},transition:{value:0}},vertexShader:"varying vec2 vUv;        void main() {          vUv = uv;          gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n        }",fragmentShader:["varying vec2 vUv;","uniform float transition;","uniform sampler2D saoAccumulationBuffer;","void main() {","float aoValue = texture2D( saoAccumulationBuffer, vUv).r;","gl_FragColor = vec4(mix(0., aoValue, transition));","}"].join("\n")},e.exports=PIXOTRON.SmoothTransitionShadowShader={uniforms:{shadowAccumulationBuffer:{value:null},firstFrameShadowBuffer:{value:null},transition:{value:0}},vertexShader:"varying vec2 vUv;        void main() {          vUv = uv;          gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n        }",fragmentShader:["#include <packing>","varying vec2 vUv;","uniform float transition;","uniform sampler2D shadowAccumulationBuffer;","uniform sampler2D firstFrameShadowBuffer;","void main() {","float shadowValueFirstFrame = unpackRGBAToDepth(texture2D( firstFrameShadowBuffer, vUv));","float shadowValue = unpackRGBAToDepth(texture2D( shadowAccumulationBuffer, vUv));","gl_FragColor = vec4(mix(shadowValueFirstFrame, shadowValue, pow(transition, 4.)));","}"].join("\n")},e.exports=PIXOTRON.SmoothTransitionSoftShadowShadowShader={defines:{SHADOW_MATERIAL:1},uniforms:{shadowAccumulationBuffer:{value:null},transition:{value:0},shadowData:{value:new THREE.Vector3(1,2,1)}},vertexShader:"varying vec2 vUv;        void main() {          vUv = uv;          gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n        }",fragmentShader:["#include <packing>","varying vec2 vUv;","uniform float transition;","uniform vec3 shadowData;","uniform sampler2D shadowAccumulationBuffer;","void main() {","#if SHADOW_MATERIAL == 1","float shadowValue = unpackRGBAToDepth(texture2D( shadowAccumulationBuffer, vUv));","float mask = (1. - shadowValue) * shadowData.x;","mask = pow(mask, shadowData.y);","gl_FragColor =  vec4(mix(vec4(0.), vec4(vec3(0.), mask), pow(transition, 4.)));","#else","float shadowValue = unpackRGBAToDepth(texture2D( shadowAccumulationBuffer, vUv));","float mask = (1. - shadowValue);","mask = pow(shadowValue, shadowData.y);","gl_FragColor = vec4(mask + shadowData.x);","#endif","}"].join("\n")}},function(e,t){function i(e){return 0==(e&e-1)&&0!==e}THREE.ShaderChunk.utilshader=["vec2 pack16(float value){","float sMax = 65535.0;","int v = int(clamp(value, 0.0, 1.0)*sMax+0.5);","int digit0 = v/256;","int digit1 = v-digit0*256;","return vec2(float(digit0)/255.0, float(digit1)/255.0);","}","vec2 packNormal(vec3 n){","float p = sqrt(n.z*8.0+8.0);","return vec2(n.xy/p + 0.5);","}","vec3 unpackNormal(vec2 enc){","vec2 fenc = enc*4.0-2.0;","float f = dot(fenc,fenc);","float g = sqrt(1.0-f/4.0);","return vec3(fenc*g, 1.0-f/2.0);","}","float unpack16(vec2 value){","return (","value.x*0.996108949416342426275150501169264316558837890625 +","value.y*0.00389105058365758760263730664519243873655796051025390625",");","}","vec3 getViewNormal(const in vec2 uv ) {","#if DEPTH_NORMAL_TEXTURE == 1","return unpackNormal( texture2D( tNormalDepth, uv ).zw );","#else","return unpackRGBToNormal( texture2D( tNormal, uv ).xyz );","#endif","}","float linstep(float edge0, float edge1, float value){","return clamp((value-edge0)/(edge1-edge0), 0.0, 1.0);","}","vec3 packFloatToRGB(const in float x) {","const vec3 code = vec3(1.0, 255.0, 65025.0);","vec3 pack = vec3(code * x);","pack.gb = fract(pack.gb);","pack.rg -= pack.gb * (1.0 / 256.0);","return pack;","}","float decodeDepth( const in vec2 uv ) {","vec4 uncodedDepth;","#if DEPTH_PACKING_MODE == 2","uncodedDepth = texture2D( tNormalDepth, uv );","#else","uncodedDepth = texture2D( tDepth, uv );","#endif","#if DEPTH_PACKING_MODE == 0","return uncodedDepth.x;","#elif DEPTH_PACKING_MODE == 1","#if LINEAR_DEPTH == 1","return pow2(unpackRGBAToDepth(uncodedDepth));","#else","return unpackRGBAToDepth( uncodedDepth );","#endif","#else","return pow2(unpack16(uncodedDepth.xy));","#endif","}"].join("\n"),function(){const e=THREE.CopyShader;PIXOTRON.D=THREE.UniformsUtils.clone(e.uniforms),PIXOTRON.P=new THREE.ShaderMaterial({uniforms:PIXOTRON.D,vertexShader:e.vertexShader,fragmentShader:e.fragmentShader,depthWrite:!1,depthTest:!1}),PIXOTRON.S=new THREE.ShaderMaterial({uniforms:PIXOTRON.D,vertexShader:e.vertexShader,fragmentShader:e.fragmentShader,blending:THREE.AdditiveBlending,depthTest:!1,depthWrite:!1,transparent:!0}),PIXOTRON.M=new THREE.Scene,PIXOTRON.H=new THREE.OrthographicCamera(-1,1,1,-1,0,1),PIXOTRON.quad=new THREE.Mesh(new THREE.PlaneGeometry(2,2),PIXOTRON.P),PIXOTRON.quad.frustumCulled=!1,PIXOTRON.M.add(PIXOTRON.quad)}(),e.exports=PIXOTRON.randomizeArray=function(e){let t,i,s=e.length;for(;0!==s;)i=Math.floor(Math.random()*s),t=e[s-=1],e[s]=e[i],e[i]=t;return e},e.exports=PIXOTRON.createTextureFromRawData=function(e,t){(t=t||{}).type=t.type||THREE.FloatType,t.format=t.format||THREE.LuminanceAlphaFormat,t.minFilter=t.minFilter||THREE.NearestFilter,t.magFilter=t.magFilter||THREE.NearestFilter;const i=new Float32Array(2*e.length);for(let t=0;t<2*e.length;t+=2)i[t]=e[t/2].x-.5,i[t+1]=e[t/2].y-.5;const s=new THREE.DataTexture(i,e.length,1);return s.format=t.format,s.type=t.type,s.minFilter=t.minFilter,s.magFilter=t.magFilter,s.generateMipmaps=!1,s.needsUpdate=!0,s},e.exports=PIXOTRON.jitterCamera=function(e,t,i,s,a){a=void 0!==a?a:.5;const r=(2*t.x-1)*a,o=(2*t.y-1)*a;e.setViewOffset(i,s,r,o,i,s)},e.exports=PIXOTRON.insideCircle=function(e,t,i){const s=e-.5,a=t-.5;return s*s+a*a<=(i=void 0!==i?i:.5)*i},e.exports=PIXOTRON.insideRectangle=function(e,t,i,s){return i=void 0!==i?i:1,s=void 0!==s?s:1,e>=0&&t>=0&&e<=i&&t<=s},e.exports=PIXOTRON.blit=function(e,t,i,s){s=void 0!==s&&s,PIXOTRON.D.tDiffuse.value=t,PIXOTRON.quad.material=PIXOTRON.P,e.setRenderTarget(i),e.render(PIXOTRON.M,PIXOTRON.H),e.setRenderTarget(null)},e.exports=PIXOTRON.blitTransparent=function(e,t,i,s){s=void 0!==s&&s,PIXOTRON.D.tDiffuse.value=t,PIXOTRON.quad.material=PIXOTRON.S,e.setRenderTarget(i),e.render(PIXOTRON.M,PIXOTRON.H),e.setRenderTarget(null)},e.exports=PIXOTRON.renderPass=function(e,t,i,s){s=void 0!==s&&s,PIXOTRON.quad.material=t,e.setRenderTarget(i),e.render(PIXOTRON.M,PIXOTRON.H),e.setRenderTarget(null)},e.exports=PIXOTRON.calculateFOV=function(e,t,i){let s;e.isBox3?s=e:(s=new THREE.Box3).setFromObject(e);const a=new THREE.Vector3;s.getCenter(a);const r=new THREE.Vector3;s.getSize(r);const o=new THREE.Vector3;o.set(r.x/2,r.y/2,r.z/2),o.add(a),o.sub(t),o.normalize();let n=i.dot(o);return o.set(-r.x/2,r.y/2,r.z/2),o.add(a),o.sub(t),o.normalize(),n=Math.min(i.dot(o),n),o.set(r.x/2,-r.y/2,r.z/2),o.add(a),o.sub(t),o.normalize(),n=Math.min(i.dot(o),n),o.set(r.x/2,r.y/2,-r.z/2),o.add(a),o.sub(t),o.normalize(),n=Math.min(i.dot(o),n),o.set(-r.x/2,-r.y/2,-r.z/2),o.add(a),o.sub(t),o.normalize(),n=Math.min(i.dot(o),n),o.set(-r.x/2,r.y/2,-r.z/2),o.add(a),o.sub(t),o.normalize(),n=Math.min(i.dot(o),n),o.set(r.x/2,-r.y/2,-r.z/2),o.add(a),o.sub(t),o.normalize(),n=Math.min(i.dot(o),n),o.set(-r.x/2,-r.y/2,r.z/2),o.add(a),o.sub(t),o.normalize(),n=Math.min(i.dot(o),n),180*Math.acos(n)/Math.PI*2},e.exports=PIXOTRON.isPowerOfTwo=function(e){return i(e.width)&&i(e.height)},e.exports=PIXOTRON.makePowerOfTwo=function(e){function t(e){return Math.pow(2,Math.floor(Math.log(e)/Math.LN2))}if(e instanceof HTMLImageElement||e instanceof HTMLCanvasElement||e instanceof ImageBitmap){const i=document.createElementNS("http://www.w3.org/1999/xhtml","canvas");return i.width=t(e.width),i.height=t(e.height),i.getContext("2d").drawImage(e,0,0,i.width,i.height),i}return e},e.exports=PIXOTRON.getDataFromImage=function(e,t){const i=document.createElement("canvas"),s=t,a=t/(e.width/e.height);i.width=s,i.height=a;const r=i.getContext("2d");return r.drawImage(e,0,0,s,a),r.getImageData(0,0,s,a)},e.exports=PIXOTRON.getPixelFromImageData=function(e,t,i){const s=4*(t+e.width*i),a=e.data;return{r:a[s],g:a[s+1],b:a[s+2],a:a[s+3]}},e.exports=PIXOTRON.squareToUniformDiskConcentric=function(){const e=new THREE.Vector2;return function(t){const i=2*t.x-1,s=2*t.y-1;let a,r;0===i&&0===s?r=a=0:i*i>s*s?(r=i,a=Math.PI/4*(s/i)):(r=s,a=Math.PI/2-i/s*(Math.PI/4));const o=Math.sin(a),n=Math.cos(a);return e.x=r*n,e.y=r*o,e}}(),e.exports=PIXOTRON.squareToCosineHemisphere=function(){const e=new THREE.Vector3;return function(t){const i=PIXOTRON.squareToUniformDiskConcentric(t),s=Math.sqrt(1-i.x*i.x-i.y*i.y);return e.set(i.x,i.y,s),e}}(),e.exports=PIXOTRON.startPerformanceTest=function(e){return PIXOTRON.gpuProfiler&&PIXOTRON.gpuProfiler.start(e)},e.exports=PIXOTRON.endPerformanceTest=function(e,t){const i=PIXOTRON.gpuProfiler&&PIXOTRON.gpuProfiler.result(e);return i&&t.callback&&t.callback({time:i,name:t.name}),i}},function(e,t,i){Object.defineProperty(t,"__esModule",{value:!0}),i(25),t.default=PIXOTRON.SuperSampleAAPass=class extends THREE.Pass{constructor(){super(),this.needsSwap=!0,this.needsUpdate=!0,this.C=0,this._=new THREE.ShaderMaterial(PIXOTRON.SuperSampleAAShader)}dispose(){this.pingpongRT&&this.pingpongRT.dispose(),this._.dispose()}render(e,t,i){const s=e.getClearColor(),a=e.getClearAlpha(),r=e.autoClear;e.autoClear=!1,e.setClearColor(new THREE.Color(0,0,0),0),this.needsUpdate&&(this.C=0,this.needsUpdate=!1),this.I||this.X(e),this.C++,this._.uniforms.tCurrent.value=i.texture,this._.uniforms.tSumPrevious.value=this.I.texture,this._.uniforms.accIndex.value=this.C,PIXOTRON.renderPass(e,this._,t),PIXOTRON.blit(e,t,this.I),e.autoClear=r,e.setClearColor(s,a)}setSize(e,t){this.I&&this.I.setSize(e,t)}X(e){const t={minFilter:THREE.LinearFilter,magFilter:THREE.LinearFilter,format:THREE.RGBAFormat},i=new THREE.Vector2;e.getDrawingBufferSize(i);const s=i.x,a=i.y;this.I=new THREE.WebGLRenderTarget(s,a,t)}}},function(e,t,i){e.exports=PIXOTRON={},i(6),i(3),i(7),i(9),i(10),i(1),i(12),i(13),i(0),i(14),i(16),i(18),i(20),i(22),i(4),i(26),i(28),i(30),i(32),i(33),i(35);const s=new THREE.Vector2;e.exports=PIXOTRON.Pixotron=class extends THREE.EventDispatcher{constructor(e){super(),(e=e||{}).saoparams=e.saoparams||{},e.shadowparams=e.shadowparams||{},e.gbufferparams=e.gbufferparams||{},e.outlineparams=e.outlineparams||{},this.needsUpdate=!0,this.autoSAOClear=!0,this.autoShadowsClear=!0,this.enableAA=!0,this.A=new PIXOTRON.BilateralFilterPass(3,1),this.F=new PIXOTRON.GBufferPass(e.gbufferparams);const t=e.giParams||{};this.enableGI=!!t.enable,this.enableGI&&this.initializeGI(t),this.U=new PIXOTRON.BVHManager;const i=void 0===e.saoparams.accumulative||e.saoparams.accumulative;this.V=i?new PIXOTRON.AccumulativeSAOPass(e.saoparams):new PIXOTRON.SAOPass(e.saoparams),this.L=new PIXOTRON.ShadowPass(e.shadowparams),this.B=new PIXOTRON.SuperSampleAAPass,this.k=PIXOTRON.generateQuasiRandomPoints(30,-1,PIXOTRON.uniformDistribution,PIXOTRON.insideRectangle),this.W=new PIXOTRON.OutlinePass(e.outlineparams);const s={format:THREE.RGBAFormat,minFilter:THREE.NearestFilter,magFilter:THREE.NearestFilter};this.j=new THREE.WebGLRenderTarget(1,1,s),this.Z=new THREE.WebGLRenderTarget(1,1,s),this.C=0,this.G=null,this.q=null,this.K=[],this.K.push(this.A),this.K.push(this.F),this.K.push(this.V),this.K.push(this.L),this.K.push(this.W),this.J=0,this.debug=!1,this.Y=new PIXOTRON.Performance(this),this.$=null}addNodeToAccelerationStructure(e,t){t?this.U.add(e):e.traverse(e=>{e.isMesh&&e.castShadow&&(e.updateMatrixWorld(),this.U.add(e))})}addRenderCompleteCallback(e){this.renderCompleteCallback=e,this.addEventListener("onRenderConverged",e)}removeRenderCompleteCallback(){this.removeEventListener("onRenderConverged",this.renderCompleteCallback),this.renderCompleteCallback=null}blit(e){if(this.tt){const t=e||null;PIXOTRON.blit(this.renderer,this.tt,t,!1)}this.blitHighlights()}dispose(){this.K.forEach(e=>{e.dispose()}),this.et.renderTarget1.dispose(),this.et.renderTarget2.dispose(),this.j.dispose(),this.Z.dispose()}enableVPLGeneration(){this.it&&(this.it.st=!0)}getBloomPass(){return this.ot}getGBufferPass(){return this.F}getHighLightPass(){return this.W}getRenderPass(){return this.at}getSAOPass(){return this.V}getShadowPass(){return this.L}getTotalRenderTime(){return this.J}getVPLGenerationPass(){return this.it}highlightObjects(e){this.nt=e}initializeGI(e){this.it=new PIXOTRON.VPLGenerationPass(500),this.ht=new PIXOTRON.InstantRadiosityPass,this.K.push(this.it),this.K.push(this.ht)}insertPass(e,t){this.et.insertPass(e,t)}isAccumulationConverged(){const e=this.L.enableAccumulation,t=this.V.convergenceMetric()>=1,i=!e||this.L.convergenceMetric()>=1,s=!this.enableGI||this.ht.convergenceMetric()>=1;return i&&t&&s}isSuperSamplingConverged(){return this.C/this.k.length>=1}renderFrame(e,t,i,s){for(this.needsUpdate=!0;!this.isSuperSamplingConverged();)this.render(e,t,i,s)}render(e,t,i,s){if(this.needsUpdate&&(this.rt(),this.C=0,this.jitterIndex=0,this.needsUpdate=!1,this.autoSAOClear=!0,this.autoShadowsClear=!0),!this.G||this.G.uuid===i.uuid&&this.q.uuid===t.uuid||(this.G=i,this.q=t,this.at.camera=this.G,this.at.scene=this.q,this.lt.G=this.G,this.lt.ct.copy(this.G.projectionMatrix)),this.bInitialized||this.X(e,t,i,s),this.ut(t),this.enableGI&&this.it.generateVPLs(t,this.areaLights[0],10,this.U),this.isSuperSamplingConverged()&&this.dt(),!this.isSuperSamplingConverged()){this.vt(e,t,i),this.ft();const s=this.isAccumulationConverged();this.B.enabled=s||0!==this.C,this.lt.enabled=this.enableAA&&(0===this.C||!s),this.pt(i),this.et.writeBuffer=this.et.renderTarget1,this.et.readBuffer=this.et.renderTarget2,this.J=0,this.queryId=this.debug&&PIXOTRON.startPerformanceTest(this.queryId),this.et.render(),this.debug&&PIXOTRON.endPerformanceTest(this.queryId,{callback:this.debugCallback,name:"Composer Render"}),i.clearViewOffset(),this.jitterIndex++,this.B.enabled&&this.C++,this.Y.update(),this.$&&this.$.update()}s&&this.Et(this.q,this.G)}setQualityAdapter(e){if(this.$&&this.$.disable(),e&&this.$){const t=this.$.getCurrentQualitySetting(),i=e.getCurrentQualitySetting();t&&i&&t.getQuality()!==i.getQuality()&&e.setQualitySetting(t)}this.$=e,this.$.enable()}setSize(e,t){let i=e,s=t;this.renderer&&(i*=this.renderer.getPixelRatio(),s*=this.renderer.getPixelRatio(),i=Math.floor(i),s=Math.floor(s),this.renderer.screenBufferSize=new THREE.Vector2(i,s)),this.F.setSize(i,s),this.V.setSize(i,s),this.L.setSize(i,s),this.et&&this.et.setSize(i,s),this.needsUpdate=!0}setAntiAliasingFeedBackParams(e,t){this.lt&&(this.lt.feedBack.x=e,this.lt.feedBack.y=t)}pt(e){if(this.enableAA||this.isAccumulationConverged()){this.renderer.getDrawingBufferSize(s);const t=s.x,i=s.y,a=this.k[this.jitterIndex%this.k.length];PIXOTRON.jitterCamera(e,a,t,i)}if(this.isAccumulationConverged()){const e=this.k[this.jitterIndex%this.k.length];this.wt(e)}}ft(){this.V.enabled||(this.renderer.saoBuffer=this.Z.texture);const e=this,t=!this.L.enabled,i=!function(){let t=!0;return e.areaLights.forEach(e=>{e.castShadow||(t=!1)}),t}(),s=0===this.areaLights.length;(t||i||s)&&this.L.lights.forEach(e=>{e.shadow.map=this.j})}blitHighlights(){if(!this.getHighLightPass()||!this.nt)return;if(!this.nt[0])return;const e=this.renderer.autoClear;this.renderer.autoClear=!1,PIXOTRON.blitTransparent(this.renderer,this.getHighLightPass().Rt,null),this.renderer.autoClear=e}Tt(){this.J+=this.F.getTotalRenderTime(),this.J+=this.V.getTotalRenderTime(),this.J+=this.L.getTotalRenderTime()}dt(){this.renderCompleteCallbackCalled||(this.dispatchEvent({type:"onRenderConverged",message:""}),this.renderCompleteCallbackCalled=!0)}ut(e){const t=this;this.punctualLights=[],this.areaLights=[],e.traverseVisible((function(e){(e instanceof THREE.DirectionalLight||e instanceof THREE.SpotLight)&&e.castShadow&&t.punctualLights.push(e),e instanceof THREE.RectAreaLight&&e.castShadow&&(e.shadow=e.shadow?e.shadow:{},e.C=e.C?e.C:0,t.areaLights.push(e))})),this.L.lights=this.areaLights}wt(e){this.punctualLights.forEach(t=>{PIXOTRON.jitterCamera(t.shadow.camera,e,t.shadow.mapSize.x,t.shadow.mapSize.y)})}X(e,t,i,s){this.renderer=e,this.G=i,this.q=t,this.tt=s,this.at=new THREE.RenderPass(t,i),this.et=new THREE.EffectComposer(this.renderer,s);const a=new THREE.Vector2;e.getDrawingBufferSize(a),this.B.setSize(a.x,a.y),this.renderer.screenBufferSize=new THREE.Vector2(a.x,a.y),this.lt=new PIXOTRON.TemporalAAPass(i,this.F),this.xt=new THREE.ShaderPass(THREE.CopyShader),this.xt.needsSwap=!1,this.xt.renderToScreen=!s,this.et.addPass(this.at),this.ot=new PIXOTRON.UnrealBloomPass(this.F,new THREE.Vector2(a.width,a.height),.86,1,.98),this.et.addPass(this.ot),this.K.push(this.ot),this.et.addPass(this.B),this.et.addPass(this.lt),this.K.push(this.B),this.K.push(this.lt),this.ot.enabled=!1,this.et.addPass(this.xt),this.bInitialized=!0;const r=new THREE.MeshBasicMaterial({color:16777215}),o=new THREE.MeshBasicMaterial({color:0});PIXOTRON.renderPass(e,r,this.j),PIXOTRON.renderPass(e,o,this.Z),this.Ot=e.getContext(),this.Nt=this.Ot&&this.Ot.getExtension("EXT_disjoint_timer_query"),PIXOTRON.gpuProfiler=this.Nt&&new PIXOTRON.GPUProfiler(this.Ot),this.punctualLights=[],this.areaLights=[],this.jitterIndex=0}vt(e,t,i){e.getDrawingBufferSize(s);const a=s.x,r=s.y,o=this.k[this.jitterIndex%this.k.length];PIXOTRON.jitterCamera(i,o,a,r),this.F.render(e,t,i),this.V.render(e,i,this.F,this.A),this.L.render(e,t,i),this.enableGI&&this.ht.render(e,t,i,this.it,this.areaLights[0]),i.clearViewOffset(),!this.et.renderTarget1.depthTexture&&this.F.Dt&&(this.et.renderTarget1.depthTexture=this.F.Dt,this.et.renderTarget2.depthTexture=this.F.Dt)}Et(e,t){if(this.W&&this.nt&&this.nt[0]){const i=1===this.jitterIndex||this.gt();this.W.needsUpdate=i,!i&&this.W.isConverged()||this.W.render(this.renderer,e,t,this.nt)}this.Pt=this.nt}gt(){if(!this.Pt)return!0;if(this.nt===this.Pt)return!1;if(null===this.nt||null===this.Pt)return!1;if(this.nt.length!==this.Pt.length)return!0;for(let e=0;e<this.nt.length;++e)if(this.Pt[e]&&this.nt[e].id!==this.Pt[e].id)return!0;return!1}rt(){this.V.needsUpdate=!!this.autoSAOClear,this.L.needsUpdate=!!this.autoShadowsClear,this.B.needsUpdate=!0,this.W&&(this.W.needsUpdate=!0),this.enableGI&&(this.ht.needsUpdate=!0),this.renderCompleteCallbackCalled=!1}}},function(e,t){e.exports=PIXOTRON.Performance=class{constructor(e){this.u=e,this.St=performance.now(),this.Mt=performance.now(),this.converged=this.converged.bind(this),this.Ht=0,this.Ct=0,this.yt=0,this.rt=!0,this.FPS_UPDATE_TIME=500,this.u.addEventListener("onRenderConverged",this.converged)}update(){if(this.Ht++,this.St=performance.now(),this.rt&&(this._t(),this.rt=!1),this.St>=this.Mt+this.FPS_UPDATE_TIME){const e=this.St-this.Mt;this.Ct=1e3*this.Ht/e,this.Ht=0,this.Mt=this.St,this.u.dispatchEvent({type:"onFPSUpdate",fps:this.Ct,delta:e})}}_t(){this.Ht=0,this.St=performance.now(),this.Mt=performance.now()}converged(){this.rt=!0}}},function(e,t,i){i(8),e.exports=PIXOTRON.TextureAreaLightFilter=class{constructor(e){this.It=e,PIXOTRON.isPowerOfTwo(this.It.image)||(this.It.image=PIXOTRON.makePowerOfTwo(this.It.image));const t={format:THREE.RGBAFormat,magFilter:THREE.LinearFilter,minFilter:THREE.LinearFilter,type:this.It.type,generateMipmaps:!1,anisotropy:this.It.anisotropy,encoding:this.It.encoding},i={x:e.image.width,y:e.image.height},s=Math.max(i.x,i.y);this.zt=Math.log(s)/Math.log(2)+1,this.Xt=[],this.At=[],this.Ft=[],this.Ft.push(.1);for(let e=0;e<this.zt;e++){let s=new THREE.WebGLRenderTarget(i.x,i.y,t);this.Xt.push(s),s=new THREE.WebGLRenderTarget(i.x,i.y,t),this.At.push(s),i.x=Math.ceil(i.x/2),i.y=Math.ceil(i.y/2),e<2&&this.Ft.push(1),e<5&&this.Ft.push(2),e>5&&this.Ft.push(3)}const a=PIXOTRON.AreaLightTextureFilterShader;this.bt=new THREE.ShaderMaterial({uniforms:THREE.UniformsUtils.clone(a.uniforms),vertexShader:a.vertexShader,fragmentShader:a.fragmentShader,defines:{NUM_SAMPLES:16}})}update(e){let t=this.It;const i=new THREE.DataTexture(null,this.It.image.width,this.It.image.height);i.minFilter=THREE.LinearMipMapLinearFilter;for(let s=0;s<this.zt;s++){this.bt.uniforms.filterRadius.value=this.Ft[s],this.bt.uniforms.texSize.value.set(this.Xt[s].width,this.Xt[s].height),this.bt.uniforms.direction.value.set(1,0),this.bt.uniforms.colorTexture.value=t,PIXOTRON.renderPass(e,this.bt,this.Xt[s],!0),this.bt.uniforms.direction.value.set(0,1),this.bt.uniforms.colorTexture.value=this.Xt[s].texture,PIXOTRON.renderPass(e,this.bt,this.At[s],!0),t=this.At[s];const a=new Uint8Array(4*t.width*t.height);e.setRenderTarget(t),e.readRenderTargetPixels(t,0,0,t.width,t.height,a),i.mipmaps[s]={data:a,width:t.width,height:t.height}}return i.generateMipmaps=!1,i.needsUpdate=!0,this.Ut(),i}Ut(){for(let e=0;e<this.zt;e++)this.Xt[e].dispose(),this.Xt[e]=null,this.At[e].dispose(),this.At[e]=null}}},function(e,t){e.exports=PIXOTRON.AreaLightTextureFilterShader={uniforms:{colorTexture:{value:null},texSize:{value:new THREE.Vector2(.5,.5)},direction:{value:new THREE.Vector2(.5,.5)},filterRadius:{value:1}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;","gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["varying vec2 vUv;","uniform sampler2D colorTexture;","uniform float filterRadius;","uniform vec2 texSize;","uniform vec2 direction;","void main() {","float INV_NUM_SAMPLES = 1.0/float(NUM_SAMPLES - 1);","vec2 delta = direction * filterRadius * INV_NUM_SAMPLES/ texSize;","float fSigma = filterRadius;","float weightSum = 1.;","vec4 colorSum = texture2D( colorTexture, vUv) * weightSum;","for( int i = 1; i < NUM_SAMPLES; i ++ ) {","float x = float(i);","vec2 uvOffset = delta * x;","vec2 vUv1 = vUv + uvOffset;","float w = 1.;","if( vUv1.x < 0.0 || vUv1.x > 1.0 || vUv1.y < 0.0 || vUv1.y > 1.0 ) {","w = 0.0;","}","colorSum += texture2D( colorTexture, vUv1) * w;","weightSum += w;","vec2 vUv2 = vUv - uvOffset;","w = 1.;","if( vUv2.x < 0.0 || vUv2.x > 1.0 || vUv2.y < 0.0 || vUv2.y > 1.0 ) {","w = 0.0;","}","colorSum += texture2D( colorTexture, vUv2) * w;","weightSum += w;","}","gl_FragColor = vec4(colorSum/weightSum);","}"].join("\n")}},function(e,t){e.exports=PIXOTRON.BVHManager=class{constructor(){this.meshes=[]}buildBVHTree(e){let t=null;e.geometry.index&&(t=e.geometry.index.array);let s=e.geometry.attributes.position.array,c=e.geometry.attributes.uv?e.geometry.attributes.uv.array:void 0;if(t){const e=new Float32Array(3*t.length);for(let i=0;i<t.length;i++){const a=3*t[i];e[3*i]=s[a],e[3*i+1]=s[a+1],e[3*i+2]=s[a+2]}if(s=e,c){const e=new Float32Array(2*t.length);for(let i=0;i<t.length;i++){const s=2*t[i];e[2*i]=c[s],e[2*i+1]=c[s+1]}c=e}}return new class{constructor(e,t,s){this.positions=e,this.uvs=t,this._maxTrianglesPerNode=s||10,this._bboxArray=function(e){let t,i,s,a,r,o,n,l,u,c,d,m,f,v,p;const g=e.length/9,x=new Float32Array(7*g);for(let T=0;T<g;T++)t=e[9*T],i=e[9*T+1],s=e[9*T+2],a=e[9*T+3],r=e[9*T+4],o=e[9*T+5],n=e[9*T+6],l=e[9*T+7],u=e[9*T+8],c=Math.min(Math.min(t,a),n),d=Math.min(Math.min(i,r),l),m=Math.min(Math.min(s,o),u),f=Math.max(Math.max(t,a),n),v=Math.max(Math.max(i,r),l),p=Math.max(Math.max(s,o),u),h(x,T,T,c,d,m,f,v,p);return x}(e),this._bboxHelper=new Float32Array(this._bboxArray.length),this._bboxHelper.set(this._bboxArray);const a=e.length/9,r=this.calcExtents(0,a,i);for(this._rootNode=new u(r[0],r[1],0,a,0),this._nodesToSplit=[this._rootNode];this._nodesToSplit.length>0;){const e=this._nodesToSplit.pop();this.splitNode(e)}}calcExtents(e,t,i){if(i=i||0,e>=t)return[{x:0,y:0,z:0},{x:0,y:0,z:0}];let s=Number.MAX_VALUE,a=Number.MAX_VALUE,r=Number.MAX_VALUE,o=-Number.MAX_VALUE,n=-Number.MAX_VALUE,l=-Number.MAX_VALUE;for(let i=e;i<t;i++)s=Math.min(this._bboxArray[7*i+1],s),a=Math.min(this._bboxArray[7*i+2],a),r=Math.min(this._bboxArray[7*i+3],r),o=Math.max(this._bboxArray[7*i+4],o),n=Math.max(this._bboxArray[7*i+5],n),l=Math.max(this._bboxArray[7*i+6],l);return[{x:s-i,y:a-i,z:r-i},{x:o+i,y:n+i,z:l+i}]}splitNode(e){if(e.elementCount()<=this._maxTrianglesPerNode||0===e.elementCount())return;const t=e._startIndex,s=e._endIndex,a=[[],[],[]],r=[[],[],[]],o=[e.centerX(),e.centerY(),e.centerZ()],n=[e._extentsMax.x-e._extentsMin.x,e._extentsMax.y-e._extentsMin.y,e._extentsMax.z-e._extentsMin.z],h=[];h.length=3;for(let e=t;e<s;e++){h[0]=.5*(this._bboxArray[7*e+1]+this._bboxArray[7*e+4]),h[1]=.5*(this._bboxArray[7*e+2]+this._bboxArray[7*e+5]),h[2]=.5*(this._bboxArray[7*e+3]+this._bboxArray[7*e+6]);for(let t=0;t<3;t++)h[t]<o[t]?a[t].push(e):r[t].push(e)}const c=[];if(c.length=3,c[0]=0===a[0].length||0===r[0].length,c[1]=0===a[1].length||0===r[1].length,c[2]=0===a[2].length||0===r[2].length,c[0]&&c[1]&&c[2])return;const d=[0,1,2];let m,f;d.sort((function(e,t){return n[t]-n[e]}));for(let e=0;e<3;e++){const t=d[e];if(!c[t]){m=a[t],f=r[t];break}}const v=t,p=v+m.length,g=p,x=s;let T,w=e._startIndex;const R=m.concat(f);for(let e=0;e<R.length;e++)T=R[e],l(this._bboxArray,T,this._bboxHelper,w),w++;const E=this._bboxHelper.subarray(7*e._startIndex,7*e._endIndex);this._bboxArray.set(E,7*e._startIndex);const D=this.calcExtents(v,p,i),P=this.calcExtents(g,x,i),y=new u(D[0],D[1],v,p,e._level+1),S=new u(P[0],P[1],g,x,e._level+1);e._node0=y,e._node1=S,e.clearShapes(),this._nodesToSplit.push(y),this._nodesToSplit.push(S)}intersectRay(e,t,i){const s=[this._rootNode],l=[],h=[];let u;const c=new THREE.Vector3(1/t.x,1/t.y,1/t.z);for(;s.length>0;){const t=s.pop();if(r(e,c,t))for(t._node0&&s.push(t._node0),t._node1&&s.push(t._node1),u=t._startIndex;u<t._endIndex;u++)l.push(this._bboxArray[7*u])}const d=new THREE.Vector3,m=new THREE.Vector3,f=new THREE.Vector3,v=new THREE.Vector2,p=new THREE.Vector2,g=new THREE.Vector2,x=new THREE.Vector3,T=new THREE.Vector3,w=new THREE.Vector2,R=new THREE.Vector3(e.x,e.y,e.z),E=new THREE.Vector3(t.x,t.y,t.z);for(u=0;u<l.length;u++){const e=l[u];d.fromArray(this.positions,9*e),m.fromArray(this.positions,9*e+3),f.fromArray(this.positions,9*e+6);const t=a(d,m,f,R,E,i);t&&(this.uvs&&(v.fromArray(this.uvs,6*e),p.fromArray(this.uvs,6*e+2),g.fromArray(this.uvs,6*e+4),o(t,d,m,f,v,p,g,x,w)),n(d,m,f,T),h.push({point:t,uv:w,face:{index:e,a:d.clone(),b:m.clone(),c:f.clone(),normal:T}}))}return h}}(s,c,7)}add(e){this.meshes[e.uuid]||(this.meshes.push({id:e.uuid,val:e}),e.bvh=this.buildBVHTree(e))}intersectRay(e){const t=new THREE.Ray,i=new THREE.Matrix4;let s=[];for(let a=0;a<this.meshes.length;a++){const r=this.meshes[a].val;t.origin.copy(e.origin),t.direction.copy(e.direction),i.getInverse(r.matrixWorld),t.origin.applyMatrix4(i),t.direction.transformDirection(i);const o=r.bvh.intersectRay(t.origin,t.direction,!0);o.length>0&&o.forEach((function(t){t.object=r,t.point.applyMatrix4(r.matrixWorld),t.distance=e.origin.distanceToSquared(t.point)})),s=s.concat(o)}return s.sort((function(e,t){return e.distance>t.distance})),s}};const i=1e-6;function s(e,t,i,s){const a={min:0,max:0};return s>=0?(a.min=(e-i)*s,a.max=(t-i)*s):(a.min=(t-i)*s,a.max=(e-i)*s),a}const a=function(){const e=new THREE.Vector3,t=new THREE.Vector3,i=new THREE.Vector3,s=new THREE.Vector3;return function(a,r,o,n,l,h){t.subVectors(r,a),i.subVectors(o,a),s.crossVectors(t,i);let u,c=l.dot(s);if(c>0){if(h)return null;u=1}else{if(!(c<0))return null;u=-1,c=-c}e.subVectors(n,a);const d=u*l.dot(i.crossVectors(e,i));if(d<0)return null;const m=u*l.dot(t.cross(e));if(m<0)return null;if(d+m>c)return null;const f=-u*e.dot(s);if(f<0)return null;const v=f/c;return(new THREE.Vector3).copy(l).multiplyScalar(v).add(n)}}();function r(e,t,i){const a=s(i._extentsMin.x,i._extentsMax.x,e.x,t.x),r=s(i._extentsMin.y,i._extentsMax.y,e.y,t.y);if(a.min>r.max||r.min>a.max)return!1;(r.min>a.min||a.min!=a.min)&&(a.min=r.min),(r.max<a.max||a.max!=a.max)&&(a.max=r.max);const o=s(i._extentsMin.z,i._extentsMax.z,e.z,t.z);return!(a.min>o.max||o.min>a.max||((o.min>a.min||a.min!=a.min)&&(a.min=o.min),(o.max<a.max||a.max!=a.max)&&(a.max=o.max),a.max<0))}function o(e,t,i,s,a,r,o,n,l){return THREE.Triangle.getBarycoord(e,t,i,s,n),a.multiplyScalar(n.x),r.multiplyScalar(n.y),o.multiplyScalar(n.z),a.add(r).add(o),l.copy(a),l}function n(e,t,i,s){const a=s||new THREE.Vector3,r=new THREE.Vector3;a.subVectors(i,t),r.subVectors(e,t),a.cross(r);const o=a.lengthSq();return o>0?a.multiplyScalar(1/Math.sqrt(o)):a.set(0,0,0)}function l(e,t,i,s){i[7*s]=e[7*t],i[7*s+1]=e[7*t+1],i[7*s+2]=e[7*t+2],i[7*s+3]=e[7*t+3],i[7*s+4]=e[7*t+4],i[7*s+5]=e[7*t+5],i[7*s+6]=e[7*t+6]}function h(e,t,i,s,a,r,o,n,l){e[7*t]=i,e[7*t+1]=s,e[7*t+2]=a,e[7*t+3]=r,e[7*t+4]=o,e[7*t+5]=n,e[7*t+6]=l}class u{constructor(e,t,i,s,a){this._extentsMin=e,this._extentsMax=t,this._startIndex=i,this._endIndex=s,this._level=a,this._node0=null,this._node1=null}elementCount(){return this._endIndex-this._startIndex}centerX(){return.5*(this._extentsMin.x+this._extentsMax.x)}centerY(){return.5*(this._extentsMin.y+this._extentsMax.y)}centerZ(){return.5*(this._extentsMin.z+this._extentsMax.z)}clearShapes(){this._startIndex=-1,this._endIndex=-1}}},function(e,t){PIXOTRON.queryId=-1,e.exports=PIXOTRON.GPUProfiler=class{constructor(e){this.Ot=e,this.Nt=this.Ot.getExtension("EXT_disjoint_timer_query"),this.queryPool={},this.Nt||console.warn("GPUProfiler::EXT_disjoint_timer_query not supported!")}start(e){const t=this.popAvailableQuery(e);return this.Nt&&t&&t.start(this.Nt),t.id}result(e){let t;const i=this.queryPool[e];if(i)return this.end(i),this.available(i)&&(t=this.value(i)),t}end(e){this.Nt&&e&&e.end(this.Nt)}available(e){if(this.Nt)return this.Nt.getQueryObjectEXT(e.Vt,this.Nt.QUERY_RESULT_AVAILABLE_EXT)}value(e){if(this.Nt){let t;return this.Ot.getParameter(this.Nt.GPU_DISJOINT_EXT)||(t=1e-6*this.Nt.getQueryObjectEXT(e.Vt,this.Nt.QUERY_RESULT_EXT),e.dirty=!1),t}}Lt(e){let t=this.queryPool[e];return t||(t=new class{constructor(e){this.dirty=!1,this.id=++PIXOTRON.queryId,this.Vt=e.createQueryEXT()}start(e){this.dirty||e.beginQueryEXT(e.TIME_ELAPSED_EXT,this.Vt)}end(e){this.dirty||e.endQueryEXT(e.TIME_ELAPSED_EXT),this.dirty=!0}}(this.Nt),this.queryPool[t.id]=t),t}}},function(e,t){e.exports=PIXOTRON.QualitySettings=class{constructor(e){this.Bt=void 0!==e?e:-1,this.kt=!1,this.Wt()}Wt(){this.enableAA=!0,this.useAreaLight=!0,this.pixelRatio=1,this.useHDREnv=!1,this.useGBuffer=!0,this.saoQualitySettings={enabled:!0,downscale:1,enabledOnMove:!0,useNormalWeights:!0,useAccumulative:!1},this.shadowQualitySettings={enabled:!0,downscale:1,enabledOnMove:!0}}change(e){const t=e.getSAOPass();t.enabled=this.saoQualitySettings.enabled,t.setDownscaleLevel(this.saoQualitySettings.downscale),t.blurEnabled=this.saoQualitySettings.enableBlur;const i=e.getShadowPass();i.enabled=this.shadowQualitySettings.enabled,i.setDownscaleLevel(this.shadowQualitySettings.downscale),e.enableAA=this.enableAA,e.needsUpdate=!0}setQuality(e){this.Bt=e}getQuality(){return this.Bt}lock(){this.kt=!0}unLock(){this.kt=!1}isLocked(){return this.kt}onEnter(e){this.jt=e}onExit(e){this.Zt=e}onUpdate(e){this.Gt=e}enter(){this.jt&&this.jt()}update(){this.Gt&&this.Gt()}exit(){this.Zt&&this.Zt()}},e.exports=PIXOTRON.TestQualitySettings=class extends PIXOTRON.QualitySettings{constructor(e){super(e),this.Qt=0}setTestFps(e){this.Qt=e}getTestFps(){return this.Qt}},e.exports=PIXOTRON.HighestQualitySettings=class extends PIXOTRON.QualitySettings{constructor(){super(3),this.enableAA=!0,this.useAreaLight=!1,this.pixelRatio=2,this.useHDREnv=!1,this.useGBuffer=!1,this.saoQualitySettings={enabled:!0,downscale:1,enableBlur:!0,enabledOnMove:!1,useNormalWeights:!1,useAccumulative:!1},this.shadowQualitySettings={enabled:!0,downscale:1,enabledOnMove:!1}}},e.exports=PIXOTRON.HighQualitySettings=class extends PIXOTRON.QualitySettings{constructor(){super(2),this.enableAA=!0,this.useAreaLight=!0,this.pixelRatio=1,this.useHDREnv=!1,this.useGBuffer=!0,this.saoQualitySettings={enabled:!0,downscale:1,enableBlur:!0,enabledOnMove:!0,useNormalWeights:!0,useAccumulative:!1},this.shadowQualitySettings={enabled:!0,downscale:1,enabledOnMove:!0}}},e.exports=PIXOTRON.MidQualitySettings=class extends PIXOTRON.QualitySettings{constructor(){super(1),this.enableAA=!0,this.useAreaLight=!0,this.pixelRatio=1,this.useHDREnv=!1,this.useGBuffer=!0,this.saoQualitySettings={enabled:!0,downscale:1,enableBlur:!1,enabledOnMove:!0,useNormalWeights:!0,useAccumulative:!1},this.shadowQualitySettings={enabled:!0,downscale:1,enabledOnMove:!1}}},e.exports=PIXOTRON.LowQualitySettings=class extends PIXOTRON.QualitySettings{constructor(){super(0),this.enableAA=!0,this.useAreaLight=!0,this.pixelRatio=1,this.useHDREnv=!1,this.useGBuffer=!1,this.saoQualitySettings={enabled:!1,downscale:2,enableBlur:!1,enabledOnMove:!1,useNormalWeights:!1,useAccumulative:!1},this.shadowQualitySettings={enabled:!0,downscale:2,enabledOnMove:!1}}},e.exports=PIXOTRON.LowestQualitySettings=class extends PIXOTRON.QualitySettings{constructor(){super(-1),this.enableAA=!1,this.useAreaLight=!1,this.pixelRatio=1,this.useHDREnv=!1,this.useGBuffer=!1,this.saoQualitySettings={enabled:!1,downscale:2,enableBlur:!1,enabledOnMove:!1,useNormalWeights:!1,useAccumulative:!1},this.shadowQualitySettings={enabled:!1,downscale:2,enabledOnMove:!1}}}},function(e,t,i){i(1),e.exports=PIXOTRON.AutoQualityAdapter=class extends PIXOTRON.QualityAdapter{constructor(e){super(e),this.qt=this.qt.bind(this),this.Kt=this.Kt.bind(this),this.Jt=[],this.Yt=0,this.$t=0,this.te=3,this.ee=5e3,this.ie=0,this.timeElapsed=0,this.se=30,this.oe=!1,this.T=!1}addQuality(e){this.Jt.push(e),this.Jt.sort((e,t)=>e.getQuality()>t.getQuality()?-1:1);const t=this.Jt[0];this.O(t)}needsChange(){this.oe=!0}tryUpgrade(){this.R=!0}setQualitySetting(e){if(this.rt(),!this.ae(e))throw new Error("AutoQualityAdapter:: quality not added");this.tryUpgrade(),this.O(e)}setDesiredFps(e){this.se=e}setMaxWaitTime(e){this.ee=e}setNumWaitCycles(e){this.te=e}enable(){this.v=!0,this.u.addEventListener("onFPSUpdate",this.qt),this.u.addEventListener("onRenderConverged",this.Kt)}disable(){this.v=!1,this.u.removeEventListener("onFPSUpdate",this.qt),this.u.removeEventListener("onRenderConverged",this.Kt)}getAverageFps(){return this.$t}update(){this.ne()&&(this.currentQualitySetting.update(),this.he(),this.ie=0)}ae(e){for(let t=0;t<this.Jt.length;++t)if(e.getQuality()===this.Jt[t].getQuality())return!0;return!1}rt(){this.timeElapsed=0,this.Yt=0}qt(e){this.timeElapsed+=e.delta,this.re(e.fps),this.T&&this.$t}ne(){const e=this.ie>=this.te,t=this.timeElapsed>this.ee,i=this.oe||e||t;return this.oe=!1,i}Kt(){this.ie++}re(e){this.Yt++,this.$t=this.$t*(this.Yt-1)+e,this.$t/=this.Yt}le(e){return this.$t>=e}ce(){let e;for(let t=0;t<this.Jt.length;++t)this.Jt[t].getQuality()===this.currentQualitySetting.getQuality()&&(e=t);return e}ue(){let e=this.ce()-1;return e=Math.max(e,0),this.Jt[e]}de(){let e=this.ce()+1;return e=Math.min(e,this.Jt.length-1),this.Jt[e]}ve(){return!this.previousQualitySetting||!!this.R||this.previousQualitySetting.getQuality()<=this.currentQualitySetting.getQuality()}he(){if(this.rt(),this.currentQualitySetting.isLocked())this.T;else{if(this.le(this.se)){if(!this.ve())return void this.T;{const e=this.ue();this.O(e)}}else{const e=this.de();this.O(e)}this.R=!1}}},e.exports=PIXOTRON.AutoTestQualityAdapter=class extends PIXOTRON.AutoQualityAdapter{constructor(e){super(e)}getAverageFps(){return this.currentQualitySetting.getTestFps()}qt(e){this.timeElapsed+=e.delta,e.fps=this.currentQualitySetting.getTestFps(),this.re(e.fps),this.T&&this.$t}}},function(e,t,i){i(1),e.exports=PIXOTRON.ManualQualityAdapter=class extends PIXOTRON.QualityAdapter{constructor(e){super(e),this.update=this.update.bind(this),this.qualitySettings=0}setQualitySetting(e){this.O(e)}}},function(e,t,i){i(15),e.exports=PIXOTRON.GBufferPass=class{constructor(e){e=e||{},this.forceDepthAndNormalPass=void 0===e.forceDepthAndNormalPass||e.forceDepthAndNormalPass,this.packingMode=void 0!==e.packingMode?e.packingMode:PIXOTRON.GBufferPass.DEPTH_NORMAL_16,this.me=new THREE.MeshNormalMaterial,this.fe=new THREE.ShaderMaterial(PIXOTRON.PackingShader_DepthNormal16),this.pe=void 0===e.linearDepth||e.linearDepth,this.pe?(this.Ee=new THREE.ShaderMaterial(PIXOTRON.PackingShader_Depth32),this.forceDepthAndNormalPass=!0):(this.Ee=new THREE.MeshDepthMaterial,this.Ee.depthPacking=THREE.RGBADepthPacking),this.debug=!1,this.J=0}dispose(){this.we&&this.we.dispose(),this.Re&&this.Re.dispose(),this.Te&&this.Te.dispose(),this.me.dispose(),this.fe.dispose(),this.Ee.dispose()}getTotalRenderTime(){return this.J}setSize(e,t){this.we&&this.we.setSize(e,t),this.Re&&this.Re.setSize(e,t),this.Te&&this.Te.setSize(e,t)}render(e,t,i){this.xe||this.X(e);const s=e.getClearColor(),a=e.getClearAlpha(),r=e.autoClear,o=e.shadowMap.enabled;e.shadowMap.enabled=!1,e.autoClear=!1,e.setClearColor(new THREE.Color(0,0,0),0),this.Oe(e,t,i),e.autoClear=r,e.shadowMap.enabled=o,e.setClearColor(s,a)}X(e){const t=e.extensions.get("WEBGL_depth_texture"),i=new THREE.Vector2;e.getDrawingBufferSize(i);const s=i.x,a=i.y;if(!this.forceDepthAndNormalPass&&t&&!this.Te){const e={minFilter:THREE.NearestFilter,magFilter:THREE.NearestFilter,format:THREE.RGBAFormat};this.Te=new THREE.WebGLRenderTarget(s,a,e),this.Dt||(this.Dt=new THREE.DepthTexture,this.Dt.type=THREE.UnsignedShortType),this.Te.depthTexture=this.Dt}if(!t||this.forceDepthAndNormalPass){const e={minFilter:THREE.NearestFilter,magFilter:THREE.NearestFilter,format:THREE.RGBAFormat};this.packingMode===PIXOTRON.GBufferPass.NONE&&(this.Re||(this.Re=new THREE.WebGLRenderTarget(s,a,e),this.Re.depthTexture=this.Dt),this.Te||(this.Te=new THREE.WebGLRenderTarget(s,a,e),this.Te.depthTexture=this.Dt)),this.packingMode===PIXOTRON.GBufferPass.DEPTH_NORMAL_16&&(this.we||(this.we=new THREE.WebGLRenderTarget(s,a,e),this.we.depthTexture=this.Dt))}this.xe=!0}Oe(e,t,i){!function(e){e.traverse((function(e){if(e.isMesh||e.isLineSegments||e.isLine||e.isLineLoop||e.isPoints){let t=e.material&&e.material.transparent||e.castAO;(t=(t=e.material&&e.material.transparent&&!e.material.isShadowMaterial||!!e.castAO)||e.material.alphaTest>0)&&(e.aoVisibility=e.visible,e.visible=!1)}}))}(t),this.queryId=this.debug&&PIXOTRON.startPerformanceTest(this.queryId),this.J=0;const s=e.extensions.get("WEBGL_depth_texture");s&&!this.forceDepthAndNormalPass&&(t.overrideMaterial=this.me,e.setRenderTarget(this.Te),e.clear(!0,!0,!1),e.render(t,i),e.setRenderTarget(null),t.overrideMaterial=null),s&&!this.forceDepthAndNormalPass||(this.packingMode===PIXOTRON.GBufferPass.NONE&&(t.overrideMaterial=this.me,e.setRenderTarget(this.Te),e.clear(!0,!0,!1),e.render(t,i),e.setRenderTarget(null),t.overrideMaterial=null,t.overrideMaterial=this.Ee,this.Ee.isMeshDepthMaterial||(this.Ee.uniforms.cameraNearFar.value.x=i.near,this.Ee.uniforms.cameraNearFar.value.y=i.far),e.setRenderTarget(this.Re),e.clear(!0,!0,!1),e.render(t,i,this.Re),e.setRenderTarget(null),t.overrideMaterial=null),this.packingMode===PIXOTRON.GBufferPass.DEPTH_NORMAL_16&&(t.overrideMaterial=this.fe,this.fe.uniforms.cameraNearFar.value.x=i.near,this.fe.uniforms.cameraNearFar.value.y=i.far,e.setRenderTarget(this.we),e.clear(!0,!0,!1),e.render(t,i),e.setRenderTarget(null),t.overrideMaterial=null));const a=this.debug&&PIXOTRON.endPerformanceTest(this.queryId,{callback:this.debugCallback,name:"GBuffer Pass"});a&&(this.J+=a),function(e){e.traverse((function(e){e.aoVisibility&&(e.visible=e.aoVisibility,e.aoVisibility=void 0)}))}(t)}},PIXOTRON.GBufferPass.NONE=0,PIXOTRON.GBufferPass.DEPTH_NORMAL_16=1},function(e,t){e.exports=PIXOTRON.PackingShader_DepthNormal16={uniforms:{cameraNearFar:{type:"v2",value:new THREE.Vector2}},vertexShader:"varying vec3 viewNormal;      varying vec3 viewPosition;      void main() {        viewNormal = normalMatrix * normal;        viewPosition = (modelViewMatrix * vec4( position, 1.0 )).xyz;        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );      }",fragmentShader:"varying vec3 viewNormal;    uniform vec2 cameraNearFar;    varying vec3 viewPosition;      vec2 pack16(float value){          float sMax = 65535.0;          int v = int(clamp(value, 0.0, 1.0)*sMax+0.5);          int digit0 = v/256;          int digit1 = v-digit0*256;          return vec2(float(digit0)/255.0, float(digit1)/255.0);      }            vec2 packNormal(vec3 n){          float p = sqrt(n.z*8.0+8.0);          return vec2(n.xy/p + 0.5);      }            float linstep(float edge0, float edge1, float value){        return clamp((value-edge0)/(edge1-edge0), 0.0, 1.0);      }            void main() {        float linearZ = linstep(-cameraNearFar.x, -cameraNearFar.y, viewPosition.z);        vec2 packedZ = pack16(pow(linearZ, 0.5));        vec2 packedNormal = packNormal(normalize(viewNormal));        gl_FragColor = vec4(packedZ.x, packedZ.y, packedNormal.x, packedNormal.y);      }"},e.exports=PIXOTRON.PackingShader_Depth32={uniforms:{cameraNearFar:{type:"v2",value:new THREE.Vector2}},vertexShader:"varying vec3 viewPosition;    void main() {      viewPosition = (modelViewMatrix * vec4( position, 1.0 )).xyz;      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );    }",fragmentShader:"#include <packing>  uniform vec2 cameraNearFar;  varying vec3 viewPosition;    float linstep(float edge0, float edge1, float value){      return clamp((value-edge0)/(edge1-edge0), 0.0, 1.0);    }        void main() {      float linearZ = linstep(-cameraNearFar.x, -cameraNearFar.y, viewPosition.z);      vec4 packedZ = packDepthToRGBA(pow(linearZ, 0.5));      gl_FragColor = packedZ;    }"}},function(e,t,i){i(0),i(17),i(2);const s=new THREE.Vector2;e.exports=PIXOTRON.AccumulativeSAOPass=class{constructor(e){e=e||{},this.intensity=void 0!==e.intensity?e.intensity:.25,this.occlusionWorldRadius=void 0!==e.occlusionWorldRadius?e.occlusionWorldRadius:.8,this.smoothTransition=void 0===e.smoothTransition||e.smoothTransition,this.bias=void 0!==e.bias?e.bias:.001,this.numSamples=void 0!==e.numSamples?e.numSamples:600,this.Ne=void 0!==e.samplesPerFrame?e.samplesPerFrame:4,this.De=void 0!==e.downscaleLevel?e.downscaleLevel:1,this.De=this.De<1?1:this.De,this.falloff=void 0!==e.falloff?e.falloff:1,this.blurEnabled=!0,this.edgeSharpness=10,this.debug=!1,this.enabled=!0,this.needsUpdate=!0,this.ge=0,this.Pe(this.numSamples),this.Se=new THREE.ShaderMaterial(PIXOTRON.AccumulativeSAOShader),this.Se.uniforms=THREE.UniformsUtils.clone(this.Se.uniforms),this.Se.defines.SAMPLES_PER_FRAME=this.Ne,this.Me=new THREE.ShaderMaterial(PIXOTRON.SmoothTransitionAOShader),this.C=0,this.He=[],this.J=0}convergenceMetric(){return this.enabled?this.C*this.Ne/(this.Ce-1):1}dispose(){this.ye&&(this.ye.dispose(),this._e.dispose(),this.Se.dispose(),this.Me.dispose())}getTotalRenderTime(){return this.J}render(e,t,i,a){if(this.needsUpdate&&(this.C=0,this.needsUpdate=!1),this.convergenceMetric()>=1)return;this.C++,this.C=Math.min(this.C,this.Ce-1),this.ye||this.X(e),this.Pe(this.numSamples),this.Ie(this.C-1);const r=e.getClearColor(),o=e.getClearAlpha(),n=e.autoClear;e.autoClear=!1,e.getDrawingBufferSize(s);const l=s.x/this.De,h=s.y/this.De;this.Se.uniforms.size.value.set(l,h),this.ze(l,h),this.Xe(t,i);const u=this.C%2==0?this._e:this.ye,c=this.C%2==0?this.ye:this._e;this.queryId=this.debug&&PIXOTRON.startPerformanceTest(this.queryId),this.J=0,this.Ae(e,u,c);const d=this.debug&&PIXOTRON.endPerformanceTest(this.queryId,{callback:this.debugCallback,name:"Acc SAO Render"});if(d&&(this.J+=d),this.blurEnabled&&this.convergenceMetric()>.9){this.blurQueryId=this.debug&&PIXOTRON.startPerformanceTest(this.blurQueryId),a.edgeSharpness=this.edgeSharpness,a.render(e,c,t,i);const s=this.debug&&PIXOTRON.endPerformanceTest(this.blurQueryId,{callback:this.debugCallback,name:"Acc SAO Blur"});s&&(this.J+=s)}this.Fe(e,u,c),e.autoClear=n,e.setClearColor(r),e.setClearAlpha(o),e.saoBuffer=this.smoothTransition?u:c}setDownscaleLevel(e){this.De=e||1,this.De=this.De<1?1:this.De,this.needsUpdate=!0}setSize(e,t){this._e&&this._e.setSize(e,t),this.ye&&this.ye.setSize(e,t),this.Se.uniforms.size.value.set(e,t)}X(e){e.getDrawingBufferSize(s);const t=s.x/this.De,i=s.y/this.De;if(!this.ye){const e={minFilter:THREE.NearestFilter,magFilter:THREE.NearestFilter,format:THREE.RGBAFormat};this.ye=new THREE.WebGLRenderTarget(t,i,e),this._e=new THREE.WebGLRenderTarget(t,i,e)}}Ae(e,t,i){this.Se.uniforms.tAOSumPrevious.value=t,PIXOTRON.renderPass(e,this.Se,i)}Fe(e,t,i){if(this.smoothTransition){this.Me.uniforms.saoAccumulationBuffer.value=i,this.Me.uniforms.transition.value=this.convergenceMetric(),this.transitionQueryId=this.debug&&PIXOTRON.startPerformanceTest(this.transitionQueryId),PIXOTRON.renderPass(e,this.Me,t);const s=this.debug&&PIXOTRON.endPerformanceTest(this.transitionQueryId,{callback:this.debugCallback,name:"Acc SAO Transition"});s&&(this.J+=s)}}ze(e,t){(this.ye.width!==e||this.ye.height!==t)&&this.ye.setSize(e,t)}Xe(e,t){const i=1/(2*Math.tan(THREE.Math.DEG2RAD*e.fov/2)),s=this.Se.uniforms.saoData.value;s.x=i,s.y=this.intensity,s.z=this.occlusionWorldRadius,s.w=this.C;const a=this.Se.uniforms.saoBiasEpsilon.value;a.x=this.bias,a.y=.001,a.z=this.falloff;const r=this.Se.uniforms.cameraNearFar.value;let o;r.x=e.near,r.y=e.far,this.Se.uniforms.ProjectionMatrix.value=e.projectionMatrix,o=t.Dt?t.Dt:t.Re?t.Re.texture:null;const n=t.Te?t.Te.texture:null;let l;t.Re||(l=t.we?t.we.texture:null);let h=t.Dt?0:1;t.forceDepthAndNormalPass&&t.packingMode===PIXOTRON.GBufferPass.DEPTH_NORMAL_16&&(h=2),this.Se.defines.DEPTH_PACKING_MODE=h,this.Se.defines.DEPTH_NORMAL_TEXTURE=l?1:0,this.Se.defines.LINEAR_DEPTH=t.pe?1:0,this.Se.uniforms.quasiRandomSamples.value=this.He,l?this.Se.uniforms.tNormalDepth.value=l:(this.Se.uniforms.tNormal.value=n,this.Se.uniforms.tDepth.value=o)}Ie(e){let t=this.Ne*e,i=0;for(i=0;i<this.Ne;i++)this.He[i]=this.be[t++],void 0===this.He[i]&&(this.He[i]=this.be[t%this.Ne])}Pe(e){e!==this.ge&&(this.ge=e,this.be=PIXOTRON.generateQuasiRandomPoints(e,-1,PIXOTRON.lerpDistribution,PIXOTRON.insideCircle),this.be=PIXOTRON.randomizeArray(this.be),this.Ce=this.be.length)}}},function(e,t){e.exports=PIXOTRON.AccumulativeSAOShader={blending:THREE.NoBlending,defines:{SAMPLES_PER_FRAME:4,DEPTH_PACKING_MODE:1,PERSPECTIVE_CAMERA:1,LINEAR_DEPTH:1},uniforms:{tAOSumPrevious:{type:"t",value:null},tDepth:{type:"t",value:null},tNormal:{type:"t",value:null},tNormalDepth:{type:"t",value:null},cameraNearFar:{type:"v2",value:new THREE.Vector2},saoData:{type:"v4",value:new THREE.Vector4},ProjectionMatrix:{type:"m4",value:new THREE.Matrix4},quasiRandomSamples:{type:"v2v",value:null},saoBiasEpsilon:{type:"v3",value:new THREE.Vector3(1,1,1)},size:{type:"v2",value:new THREE.Vector2(512,512)}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;","gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["#include <common>","#include <packing>","varying vec2 vUv;","uniform sampler2D tAOSumPrevious;","uniform sampler2D tDepth;","#if DEPTH_NORMAL_TEXTURE == 1","uniform sampler2D tNormalDepth;","#else","uniform sampler2D tNormal;","#endif","uniform mat4 ProjectionMatrix;","uniform vec4 saoData;","uniform vec3 saoBiasEpsilon;","uniform vec2 size;","uniform vec2 cameraNearFar;","uniform vec2 quasiRandomSamples[SAMPLES_PER_FRAME];","const float f_sampleCount = float( SAMPLES_PER_FRAME );","#include <utilshader>","float getViewDepth( const in float ndcDepth ) {","#if PERSPECTIVE_CAMERA == 1","return perspectiveDepthToViewZ( ndcDepth, cameraNearFar.x, cameraNearFar.y );","#else","return orthographicDepthToViewZ( ndcDepth, cameraNearFar.x, cameraNearFar.y );","#endif","}","vec3 getViewPositionFromViewZ(const in vec2 uv, const in float viewDepth) {","vec2 uv_ = 2. * uv - 1.;","float xe = -(uv_.x + ProjectionMatrix[2][0]) * viewDepth/ProjectionMatrix[0][0];","float ye = -(uv_.y + ProjectionMatrix[2][1]) * viewDepth/ProjectionMatrix[1][1];","return vec3(xe, ye, viewDepth);","}","float getOcclusionFromPositionNormal( const in vec3 centerPosition, const in vec3 centerNormal, const in vec3 samplePosition ) {","vec3 direction = samplePosition - centerPosition;","float d2 = dot( direction, direction );","return max( ( dot( centerNormal, direction ) + centerPosition.z * saoBiasEpsilon.x ) / ( saoBiasEpsilon.z * d2 + saoBiasEpsilon.y ), 0.0 );","}","vec4 getOcclusion( const in vec3 centerPosition ) {","vec3 centerNormal = getViewNormal( vUv );","float screenOcclusionRadius = 200. * saoData.z * saoData.x / -centerPosition.z;","if( screenOcclusionRadius < 1. ) {","discard;","}","float random = rand( vUv );","float randomAngle = random * PI2 + 2. * PI2 * (saoData.w - 1.0);","float cosAngle = cos(randomAngle); float sinAngle = sin(randomAngle);","mat2 randomRotationMatrix = mat2(cosAngle, sinAngle, -sinAngle, cosAngle);","float occlusionSum = 0.0;","for( int i = 0; i < SAMPLES_PER_FRAME; i ++ ) {","vec2 randomSample = randomRotationMatrix * (quasiRandomSamples[i] - vec2(0.5)) * screenOcclusionRadius/size;","vec2 sampleUv = vUv + randomSample;","float sampleDepthNDC = decodeDepth( sampleUv );","if( sampleDepthNDC >= ( 1.0 - EPSILON ) ) {","continue;","}","#if LINEAR_DEPTH == 0","float sampleViewDepth = getViewDepth( sampleDepthNDC );","vec3 samplePosition = getViewPositionFromViewZ( sampleUv, sampleViewDepth );","#else","sampleDepthNDC = mix(-cameraNearFar.x, -cameraNearFar.y, sampleDepthNDC);","vec3 samplePosition = getViewPositionFromViewZ(sampleUv, sampleDepthNDC);","#endif","float occlusion = getOcclusionFromPositionNormal( centerPosition, centerNormal, samplePosition );","occlusionSum += occlusion;","}","float occlusion = occlusionSum * saoData.y * 2.0 / f_sampleCount;","return vec4(clamp(occlusion,0., 1.));","}","void main() {","float centerDepth = decodeDepth( vUv );","if( centerDepth >= ( 1.0 - EPSILON ) ) {","discard;","}","#if LINEAR_DEPTH == 0","float centerViewDepth = getViewDepth( centerDepth );","#else","float centerViewDepth = mix(-cameraNearFar.x, -cameraNearFar.y, centerDepth);","#endif","vec3 viewPosition = getViewPositionFromViewZ(vUv, centerViewDepth);","float occlusion = getOcclusion( viewPosition ).r;","float prevOcclusionSum = texture2D(tAOSumPrevious, vUv).r;","float finalOcclusion = mix(prevOcclusionSum, occlusion, 1./saoData.w);","gl_FragColor.gba = packFloatToRGB( centerDepth );","gl_FragColor.r = clamp(finalOcclusion, 0., 1.);","}"].join("\n")}},function(e,t,i){i(0),i(19);const s=new THREE.Vector2;e.exports=PIXOTRON.SAOPass=class{constructor(e){e=e||{},this.intensity=void 0!==e.intensity?e.intensity:.25,this.occlusionWorldRadius=void 0!==e.occlusionWorldRadius?e.occlusionWorldRadius:.8,this.bias=void 0!==e.bias?e.bias:.001,this.De=void 0!==e.downscaleLevel?e.downscaleLevel:1,this.De=this.De<1?1:this.De,this.falloff=void 0!==e.falloff?e.falloff:1,this.blurEnabled=!0,this.edgeSharpness=1,this.debug=!1,this.enabled=!0,this.needsUpdate=!0,this.Ue=new THREE.ShaderMaterial(PIXOTRON.SAOShader),this.Ue.uniforms=THREE.UniformsUtils.clone(this.Ue.uniforms),this.Ue.defines=Object.assign({},this.Ue.defines),this.C=0,this.J=0}dispose(){this.ye&&(this.ye.dispose(),this.ye=null,this.Ue.dispose())}getTotalRenderTime(){return this.J}setDownscaleLevel(e){this.De=e||1,this.De=this.De<1?1:this.De,this.needsUpdate=!0}setSize(e,t){this.ye&&this.ye.setSize(e,t),this.Ue.uniforms.size.value.set(e,t)}convergenceMetric(){return this.enabled?this.C>1?1:0:1}render(e,t,i,a){if(!this.enabled)return;this.needsUpdate&&(this.C=0,this.needsUpdate=!1),this.ye||this.X(e),e.getDrawingBufferSize(s);const r=s.x/this.De,o=s.y/this.De;this.Ue.uniforms.size.value.set(r,o),this.ze(r,o),this.Xe(t,i);const n=e.getClearColor(),l=e.getClearAlpha(),h=e.autoClear;e.autoClear=!1,this.J=0,this.queryId=this.debug&&PIXOTRON.startPerformanceTest(this.queryId),PIXOTRON.renderPass(e,this.Ue,this.ye);const u=this.debug&&PIXOTRON.endPerformanceTest(this.queryId,{callback:this.debugCallback,name:"SAO Render"});if(u&&(this.J+=u),this.blurEnabled){this.blurQueryId=this.debug&&PIXOTRON.startPerformanceTest(this.blurQueryId),a.edgeSharpness=this.edgeSharpness,a.render(e,this.ye,t,i);const s=this.debug&&PIXOTRON.endPerformanceTest(this.blurQueryId,{callback:this.debugCallback,name:"SAO Blur"});s&&(this.J+=s)}e.autoClear=h,e.setClearColor(n),e.setClearAlpha(l),e.saoBuffer=this.ye}X(e){e.getDrawingBufferSize(s);const t=s.x/this.De,i=s.y/this.De;if(!this.ye){const e={minFilter:THREE.NearestFilter,magFilter:THREE.NearestFilter,format:THREE.RGBAFormat};this.ye=new THREE.WebGLRenderTarget(t,i,e)}}ze(e,t){(this.ye.width!==e||this.ye.height!==t)&&this.ye.setSize(e,t)}Xe(e,t){const i=1/(2*Math.tan(THREE.Math.DEG2RAD*e.fov/2)),s=this.Ue.uniforms.saoData.value;s.x=i,s.y=this.intensity,s.z=this.occlusionWorldRadius,s.w=this.C++;const a=this.Ue.uniforms.saoBiasEpsilon.value;a.x=this.bias,a.y=.001,a.z=this.falloff;const r=this.Ue.uniforms.cameraNearFar.value;let o;r.x=e.near,r.y=e.far,this.Ue.uniforms.ProjectionMatrix.value=e.projectionMatrix,o=t.Dt?t.Dt:t.Re?t.Re.texture:null;const n=t.Te?t.Te.texture:null;let l;t.Re||(l=t.we?t.we.texture:null);let h=t.Dt?0:1;t.forceDepthAndNormalPass&&t.packingMode===PIXOTRON.GBufferPass.DEPTH_NORMAL_16&&(h=2),this.Ue.defines.DEPTH_PACKING_MODE=h,this.Ue.defines.DEPTH_NORMAL_TEXTURE=l?1:0,this.Ue.defines.LINEAR_DEPTH=t.pe?1:0,l?this.Ue.uniforms.tNormalDepth.value=l:(this.Ue.uniforms.tNormal.value=n,this.Ue.uniforms.tDepth.value=o)}}},function(e,t){e.exports=PIXOTRON.SAOShader={defines:{NUM_SAMPLES:11,NUM_SPIRAL_TURNS:3,DEPTH_NORMAL_TEXTURE:0,DEPTH_PACKING_MODE:1,PERSPECTIVE_CAMERA:1},uniforms:{tDepth:{type:"t",value:null},tNormal:{type:"t",value:null},tNormalDepth:{type:"t",value:null},cameraNearFar:{type:"v2",value:new THREE.Vector2},saoData:{type:"v4",value:new THREE.Vector4},size:{type:"v2",value:new THREE.Vector2(512,512)},ProjectionMatrix:{type:"m4",value:new THREE.Matrix4},saoBiasEpsilon:{type:"v3",value:new THREE.Vector3(1,1,1)}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;","gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["#include <common>","#include <packing>","varying vec2 vUv;","uniform sampler2D tDepth;","#if DEPTH_NORMAL_TEXTURE == 1","uniform sampler2D tNormalDepth;","#else","uniform sampler2D tNormal;","#endif","uniform vec2 cameraNearFar;","uniform mat4 ProjectionMatrix;","uniform vec4 saoData;","uniform vec3 saoBiasEpsilon;","uniform vec2 size;","#include <utilshader>","const float INV_NUM_SAMPLES = 1.0 / float( NUM_SAMPLES );","float getViewZFromNDCZ( const in float depth ) {","#if PERSPECTIVE_CAMERA == 1","return perspectiveDepthToViewZ( depth, cameraNearFar.x, cameraNearFar.y );","#else","return orthographicDepthToViewZ( depth, cameraNearFar.x, cameraNearFar.y );","#endif","}","vec3 getViewPositionFromViewZ(const in vec2 uv, const in float viewDepth) {","vec2 uv_ = 2. * uv - 1.;","float xe = -(uv_.x + ProjectionMatrix[2][0]) * viewDepth/ProjectionMatrix[0][0];","float ye = -(uv_.y + ProjectionMatrix[2][1]) * viewDepth/ProjectionMatrix[1][1];","return vec3(xe, ye, viewDepth);","}","float random3(vec3 v) { ","v  = fract(v * 443.8975);","v += dot(v, v.yzx + 19.19);","return fract((v.x + v.y) * v.z);","}","vec3 getPositionFromOffset(const in vec2 uv, const in vec2 offset, const in float screenSpaceRadius) {","vec2 uvOffset = uv + floor(screenSpaceRadius * offset)/size;","float d = decodeDepth(uvOffset);","#if LINEAR_DEPTH == 0","float centerViewZ = getViewZFromNDCZ( d );","return getViewPositionFromViewZ( uvOffset, centerViewZ );","#else","d = mix(-cameraNearFar.x, -cameraNearFar.y, d);","return getViewPositionFromViewZ(uvOffset, d);","#endif","}","float getOcclusion(const in vec2 uv, const in int id, const in float randomAngle, const in float occlusionSphereRadius, const in vec3 centerPosition, const in vec3 centerNormal) {","float screenSpaceRadius = (float(id) + mod(randomAngle, 1.) + 0.5) * INV_NUM_SAMPLES; ","float angle = screenSpaceRadius * (float(NUM_SPIRAL_TURNS) * 6.28) + randomAngle; ","screenSpaceRadius = (screenSpaceRadius * occlusionSphereRadius);","vec2 offset = vec2(cos(angle), sin(angle));","vec3 samplePosition = getPositionFromOffset(uv, offset, screenSpaceRadius);","vec3 direction = samplePosition - centerPosition;","float d2 = dot( direction, direction );","float ao = max( ( dot( centerNormal, direction ) + centerPosition.z * saoBiasEpsilon.x ) / ( saoBiasEpsilon.z * d2 + saoBiasEpsilon.y ), 0.0 );","return ao;","}","void main() {","float centerDepth = decodeDepth( vUv );","if( centerDepth >= ( 1.0 - EPSILON ) ) {","discard;","}","#if LINEAR_DEPTH == 0","float centerViewZ = getViewZFromNDCZ( centerDepth );","#else","float centerViewZ = mix(-cameraNearFar.x, -cameraNearFar.y, centerDepth);","#endif","vec3 centerPosition = getViewPositionFromViewZ( vUv, centerViewZ );","vec3 centerNormal = getViewNormal(vUv);","float occlusionSphereScreenRadius = 200. * saoData.z/ (-centerPosition.z);","if( occlusionSphereScreenRadius < 1. ) {","discard;","}","float randomAngle = 6.2 * random3( vec3( vUv, saoData.w * 0.1 ) );","float sum = 0.0;","sum += getOcclusion(vUv, 0, randomAngle, occlusionSphereScreenRadius, centerPosition, centerNormal);","sum += getOcclusion(vUv, 1, randomAngle, occlusionSphereScreenRadius, centerPosition, centerNormal);","sum += getOcclusion(vUv, 2, randomAngle, occlusionSphereScreenRadius, centerPosition, centerNormal);","sum += getOcclusion(vUv, 3, randomAngle, occlusionSphereScreenRadius, centerPosition, centerNormal);","sum += getOcclusion(vUv, 4, randomAngle, occlusionSphereScreenRadius, centerPosition, centerNormal);","sum += getOcclusion(vUv, 5, randomAngle, occlusionSphereScreenRadius, centerPosition, centerNormal);","sum += getOcclusion(vUv, 6, randomAngle, occlusionSphereScreenRadius, centerPosition, centerNormal);","sum += getOcclusion(vUv, 7, randomAngle, occlusionSphereScreenRadius, centerPosition, centerNormal);","sum += getOcclusion(vUv, 8, randomAngle, occlusionSphereScreenRadius, centerPosition, centerNormal);","sum += getOcclusion(vUv, 9, randomAngle, occlusionSphereScreenRadius, centerPosition, centerNormal);","sum += getOcclusion(vUv, 10, randomAngle, occlusionSphereScreenRadius, centerPosition, centerNormal);","float aoValue = sum * saoData.y * INV_NUM_SAMPLES;","gl_FragColor.gba = packFloatToRGB( centerDepth );","gl_FragColor.r = max( aoValue, 0.0 );","}"].join("\n")}},function(e,t,i){i(0),i(2),i(21);const s=new THREE.Vector2;function a(e,t){e.traverse((function(e){(e.isMesh||e.isLineSegments||e.isLine||e.isLineLoop||e.isPoints)&&((t?e.castShadow:e.receiveShadow)||(e.oldVisibility=e.visible,e.visible=!1))}))}function r(e){e.traverse((function(e){e.oldVisibility&&(e.visible=e.oldVisibility,e.oldVisibility=void 0)}))}e.exports=PIXOTRON.ShadowPass=class{constructor(e){e=e||{},this.linearDepth=void 0!==e.linearDepth?e.linearDepth:1,this.shadowMapResolution=void 0!==e.shadowMapResolution?e.shadowMapResolution:1024,this.shadowRadius=void 0!==e.shadowRadius?e.shadowRadius:1,this.shadowQuality=void 0!==e.shadowQuality?e.shadowQuality:1,this.smoothTransition=void 0===e.smoothTransition||e.smoothTransition,this.shadowBiasMultiplier=void 0!==e.shadowBiasMultiplier?e.shadowBiasMultiplier:1,this.numSamples=void 0!==e.numSamples?e.numSamples:100,this.side=void 0!==e.side?e.side:THREE.FrontSide,this.De=void 0!==e.downscaleLevel?e.downscaleLevel:1,this.De=this.De<1?1:this.De;const t=void 0!==e.nearPlane?e.nearPlane:.1,i=void 0!==e.farPlane?e.farPlane:10,s=void 0!==e.fov?e.fov:110;this.Ve=new THREE.PerspectiveCamera(s,1,t,i),this.ge=0,this.Le(this.numSamples),this.C=0,this.Be=0,this.ke=new THREE.Vector3,this.We=new THREE.Vector3(0,-1,0),this.je=new THREE.Vector3,this.Ze=new THREE.Matrix4,this.lights=[],this.enabled=!0,this.enableAccumulation=!0,this.needsUpdate=!0,this.shadowRecieverBBox=null,this.debug=!1,this.J=0}convergenceMetric(){if(!this.enabled)return 1;let e=0;return this.lights.forEach(t=>{t.castShadow&&e++}),0!==e?this.C/(e*this.Ge.length):1}dispose(){this.Qe&&(this.Qe.dispose(),this.qe.dispose(),this.Ke.dispose(),this.Je.dispose(),this.Ee.dispose()),this.Ye&&this.Ye.dispose(),this.Me&&this.Me.dispose()}getTotalRenderTime(){return this.J}render(e,t,i){if(this.needsUpdate&&(this.C=0,this.Be=0,this.needsUpdate=!1,this.lights.forEach(e=>{e.C=0})),!this.enableAccumulation&&this.C>0)return;if(this.convergenceMetric()>=1)return;e.getDrawingBufferSize(s);const a=s.x/this.De,r=s.y/this.De;this.Qe||(this.Ve.layers.mask=i.layers.mask,this.$e(a,r)),this.ti(a,r),this.Le(this.numSamples);const o=e.getClearColor(),n=e.getClearAlpha(),l=e.autoClear;let h,u;if(this.J=0,this.lights.forEach(s=>{this.C=Math.min(this.C,this.lights.length*this.Ge.length),this.C++,s.C++,this.Be+=s.intensity,this.ei(s),this.queryId=this.debug&&PIXOTRON.startPerformanceTest(this.queryId),this.ii(e,t,this.ke,this.Qe),h=this.C%2==0?this.qe:this.Ke,u=this.C%2==0?this.Ke:this.qe,this.si(e,t,i,h,u,s),this.smoothTransition&&this.C===this.lights.length&&PIXOTRON.blit(e,u.texture,this.Je);const a=this.debug&&PIXOTRON.endPerformanceTest(this.queryId,{callback:this.debugCallback,name:"Shadow Pass"});a&&(this.J+=a)}),this.smoothTransition){this.smoothTransitionQueryId=this.debug&&PIXOTRON.startPerformanceTest(this.smoothTransitionQueryId),this.Me.uniforms.shadowAccumulationBuffer.value=u.texture,this.Me.uniforms.firstFrameShadowBuffer.value=this.Je.texture,this.Me.uniforms.transition.value=this.convergenceMetric(),PIXOTRON.renderPass(e,this.Me,h);const t=this.debug&&PIXOTRON.endPerformanceTest(this.smoothTransitionQueryId,{callback:this.debugCallback,name:"Shadow Transition"});t&&(this.J+=t)}e.autoClear=l,e.setClearColor(o),e.setClearAlpha(n),this.lights.forEach(e=>{e.shadow.map=this.smoothTransition?h:u})}setDownscaleLevel(e){this.De=e||1,this.De=this.De<1?1:this.De,this.needsUpdate=!0}setSize(e,t){this.qe&&this.qe.setSize(e,t),this.Ke&&this.Ke.setSize(e,t),this.Qe&&this.Qe.setSize(e,t),this.Je&&this.Je.setSize(e,t),this.Ye&&this.Ye.uniforms.shadowBufferSize.value.set(e,t)}ti(e,t){(this.qe.width!==e||this.qe.height!==t)&&(this.qe.setSize(e,t),this.Ke.setSize(e,t),this.Je.setSize(e,t),this.Ye.uniforms.shadowBufferSize.value=new THREE.Vector2(e,t))}$e(e,t){const i={format:THREE.RGBAFormat,minFilter:THREE.NearestFilter,magFilter:THREE.NearestFilter};this.Qe=new THREE.WebGLRenderTarget(this.shadowMapResolution,this.shadowMapResolution,i),this.qe=new THREE.WebGLRenderTarget(e,t,i),this.Ke=new THREE.WebGLRenderTarget(e,t,i),this.Je=new THREE.WebGLRenderTarget(e,t,i),this.Qe.texture.generateMipmaps=!1,this.qe.texture.generateMipmaps=!1,this.Ke.texture.generateMipmaps=!1,this.Je.texture.generateMipmaps=!1,this.linearDepth?(this.Ee=new THREE.ShaderMaterial(PIXOTRON.PackingShader_Depth32),this.Ee.uniforms=THREE.UniformsUtils.clone(this.Ee.uniforms),this.Ee.side=this.side):this.Ee=new THREE.MeshDepthMaterial({depthPacking:THREE.RGBADepthPacking,side:this.side}),this.Ye=new THREE.ShaderMaterial(PIXOTRON.AccumulativeShadowsShader),this.Ye.uniforms=THREE.UniformsUtils.clone(this.Ye.uniforms),this.Ye.uniforms.shadowBufferSize.value=new THREE.Vector2(e,t),this.Ye.uniforms.shadowMap.value=this.Qe.texture,this.Ye.uniforms.shadowData.value=new THREE.Vector4(0,1,1,1),this.Ye.uniforms.shadowMapResolution.value=new THREE.Vector2(this.shadowMapResolution,this.shadowMapResolution),this.Ye.defines.SHADOW_QUALITY=this.shadowQuality,this.Ye.defines.LINEAR_DEPTH=this.linearDepth,this.Me=new THREE.ShaderMaterial(PIXOTRON.SmoothTransitionShadowShader),this.Me.uniforms=THREE.UniformsUtils.clone(this.Me.uniforms)}si(e,t,i,s,o,n){this.Ve.matrixWorldInverse.getInverse(this.Ve.matrixWorld),this.Ze.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),this.Ze.multiply(this.Ve.projectionMatrix),this.Ze.multiply(this.Ve.matrixWorldInverse),this.Ye.uniforms.shadowMatrix.value.copy(this.Ze),this.Ye.uniforms.shadowData.value.x=this.Be,this.Ye.uniforms.shadowData.value.y=this.shadowRadius,this.Ye.uniforms.shadowData.value.z=this.shadowBiasMultiplier,this.Ye.uniforms.shadowData.value.w=n.intensity,this.Ye.uniforms.shadowAccumulationBuffer.value=s.texture,this.Ye.uniforms.vplPosition.value=this.Ve.position,this.Ye.uniforms.cameraNearFar.value.x=this.Ve.near,this.Ye.uniforms.cameraNearFar.value.y=this.Ve.far,e.setClearColor(0),a(t,!1);const l=e.shadowMap.enabled;e.shadowMap.enabled=!1,t.overrideMaterial=this.Ye,e.setRenderTarget(o),e.clear(!0,!0,!1),e.render(t,i),e.setRenderTarget(null),t.overrideMaterial=null,r(t),e.shadowMap.enabled=l}ii(e,t,i,s){a(t,!0),this.Ve.position.copy(i),this.je.copy(i),this.je.addScaledVector(this.We,10),this.Ve.lookAt(this.je),this.Ve.updateMatrixWorld(),t.overrideMaterial=this.Ee,this.linearDepth&&(this.Ee.uniforms.cameraNearFar.value.x=this.Ve.near,this.Ee.uniforms.cameraNearFar.value.y=this.Ve.far),e.setClearColor(0),e.setRenderTarget(s),e.clear(!0,!0,!1),e.render(t,this.Ve),e.setRenderTarget(null),t.overrideMaterial=null,r(t)}ei(e){let t=e.C-1;const i=e.matrixWorld;t%=this.Ge.length-1;const s=this.Ge[t];if(this.ke.x=(s.x-.5)*e.width,this.ke.z=0,this.ke.y=(s.y-.5)*e.height,this.ke.applyMatrix4(i),this.We.set(0,0,-1),this.We.transformDirection(i),this.shadowRecieverBBox){const e=PIXOTRON.calculateFOV(this.shadowRecieverBBox,this.ke,this.We);this.setFOV(e)}}setShadowRecieverBBox(e){this.shadowRecieverBBox=e}setFOV(e){this.Ve.fov=e,this.Ve.updateProjectionMatrix()}Le(e){e!==this.ge&&(this.ge=e,this.Ge=PIXOTRON.generateQuasiRandomPoints(e,-1,PIXOTRON.uniformDistribution,PIXOTRON.insideRectangle),this.Ge=PIXOTRON.randomizeArray(this.Ge),this.Ge.splice(0,0,new THREE.Vector2(.5,.5)))}}},function(e,t){e.exports=PIXOTRON.AccumulativeShadowsShader={defines:{SHADOW_QUALITY:1,LINEAR_DEPTH:1},uniforms:{shadowMap:{value:null},shadowAccumulationBuffer:{value:null},shadowBufferSize:{value:null},shadowMatrix:{value:new THREE.Matrix4},vplPosition:{value:new THREE.Vector3},shadowData:{value:new THREE.Vector4},cameraNearFar:{value:new THREE.Vector2},shadowMapResolution:{value:null},normalBias:{value:1}},vertexShader:["varying vec3 viewNormal;","varying vec3 lightVector;","varying vec4 shadowCoord;","uniform vec3 vplPosition;","uniform mat4 shadowMatrix;","uniform float normalBias;","void main() {","vec4 worldPosition = modelMatrix * vec4( position, 1.0 );","viewNormal = normalize(normalMatrix * normal);","vec3 vplPositionEyeSpace = (viewMatrix * vec4(vplPosition, 1.0)).xyz;","lightVector = vplPositionEyeSpace - (modelViewMatrix * vec4( position, 1.0 )).xyz;","lightVector = normalize(lightVector);","shadowCoord = shadowMatrix * worldPosition;","float nDotL = clamp( dot(lightVector, viewNormal), 0.0, 1.0);","worldPosition.xyz += normalize((modelMatrix * vec4( normal, 0.0 )).xyz) * 0.02 * normalBias * pow( 1.0 -  nDotL * nDotL, 4.);","shadowCoord.xy = (shadowMatrix * worldPosition).xy;","gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["#include <common>","#include <packing>","varying vec3 viewNormal;","varying vec3 lightVector;","varying vec4 shadowCoord;","uniform vec2 shadowBufferSize;","uniform vec2 shadowMapResolution;","uniform sampler2D shadowMap;","uniform sampler2D shadowAccumulationBuffer;","uniform vec4 shadowData;","uniform vec2 cameraNearFar;","float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {","#if LINEAR_DEPTH == 0","float shadowDepth = unpackRGBAToDepth( texture2D( depths, uv ) );","#else","float nDotL = clamp( dot(normalize(lightVector), normalize(viewNormal)), 0.0, 1.0);","float shadowDepth = pow2(unpackRGBAToDepth(texture2D( depths, uv ))) + 0.01 * shadowData.z;","shadowDepth = shadowDepth * ( cameraNearFar.y - cameraNearFar.x ) + cameraNearFar.x;","#endif","return step( compare, shadowDepth );","}","float texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {","const vec2 offset = vec2( 0.0, 1.0 );","vec2 texelSize = vec2( 1.0 ) / size;","vec2 centroidUV = floor( uv * size + 0.5 ) / size;","float lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );","float lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );","float rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );","float rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );","vec2 f = fract( uv * size + 0.5 );","float a = mix( lb, lt, f.y );","float b = mix( rb, rt, f.y );","float c = mix( a, b, f.x );","return c;","}","void main() {","float shadowValue = 1.0;","float shadowRadius = shadowData.y;","float shadowBiasMultiplier = shadowData.z;","float nDotL = clamp( dot(lightVector, normalize(viewNormal)), 0.0, 1.0);","float shadowBias = 0.02 *  sqrt( 1.0 -  nDotL * nDotL) / clamp(nDotL, 0.0006,  1.0);","shadowBias = clamp(shadowBias, 0.0001,  0.0003) * shadowBiasMultiplier;","vec3 shadowCoordNDC = shadowCoord.xyz/shadowCoord.w;","shadowCoordNDC.z -= shadowBias;","#if LINEAR_DEPTH == 1","float linearDepth = shadowCoord.z + 2.0*cameraNearFar.y*cameraNearFar.x/(cameraNearFar.y - cameraNearFar.x);","linearDepth *= -((cameraNearFar.y - cameraNearFar.x)/(cameraNearFar.y + cameraNearFar.x));","linearDepth = -linearDepth;","#endif","bvec4 inFrustumVec = bvec4 ( shadowCoordNDC.x >= 0.0, shadowCoordNDC.x <= 1.0, shadowCoordNDC.y >= 0.0, shadowCoordNDC.y <= 1.0 );","bool inFrustum = all( inFrustumVec );","bvec2 frustumTestVec = bvec2( inFrustum, shadowCoordNDC.z <= 1.0 );","bool frustumTest = all( frustumTestVec );","#if LINEAR_DEPTH == 1","shadowCoordNDC.z = linearDepth;","#endif","if(frustumTest) {","#if SHADOW_QUALITY == 0","shadowValue = texture2DCompare(shadowMap, shadowCoordNDC.xy, shadowCoordNDC.z);","#elif SHADOW_QUALITY == 1","vec2 texelSize = vec2( 1.0 ) / shadowMapResolution;","float dx0 = - texelSize.x * shadowRadius;","float dy0 = - texelSize.y * shadowRadius;","float dx1 = + texelSize.x * shadowRadius;","float dy1 = + texelSize.y * shadowRadius;","float theta = rand( shadowCoord.xy ) * PI2;","float snTheta = sin(theta);","float csTheta = cos(theta);","mat2 randomRotationMatrix = mat2(csTheta, snTheta, -snTheta, csTheta);","shadowValue = (","texture2DCompare( shadowMap, shadowCoordNDC.xy + randomRotationMatrix * vec2( dx0, dy0 ), shadowCoordNDC.z ) + ","texture2DCompare( shadowMap, shadowCoordNDC.xy + randomRotationMatrix * vec2( 0.0, dy0 ), shadowCoordNDC.z ) + ","texture2DCompare( shadowMap, shadowCoordNDC.xy + randomRotationMatrix * vec2( dx1, dy0 ), shadowCoordNDC.z ) + ","texture2DCompare( shadowMap, shadowCoordNDC.xy + randomRotationMatrix * vec2( dx0, 0.0 ), shadowCoordNDC.z ) + ","texture2DCompare( shadowMap, shadowCoordNDC.xy, shadowCoordNDC.z ) + ","texture2DCompare( shadowMap, shadowCoordNDC.xy + randomRotationMatrix * vec2( dx1, 0.0 ), shadowCoordNDC.z ) + ","texture2DCompare( shadowMap, shadowCoordNDC.xy + randomRotationMatrix * vec2( dx0, dy1 ), shadowCoordNDC.z ) + ","texture2DCompare( shadowMap, shadowCoordNDC.xy + randomRotationMatrix * vec2( 0.0, dy1 ), shadowCoordNDC.z ) + ","texture2DCompare( shadowMap, shadowCoordNDC.xy + randomRotationMatrix * vec2( dx1, dy1 ), shadowCoordNDC.z )",") * ( 1.0 / 9.0 );","#elif SHADOW_QUALITY == 2","vec2 texelSize = vec2( 1.0 ) / shadowMapResolution;","float dx0 = - texelSize.x * shadowRadius;","float dy0 = - texelSize.y * shadowRadius;","float dx1 = + texelSize.x * shadowRadius;","float dy1 = + texelSize.y * shadowRadius;","float theta = rand( shadowCoord.xy ) * PI2;","float snTheta = sin(theta);","float csTheta = cos(theta);","mat2 randomRotationMatrix = mat2(csTheta, snTheta, -snTheta, csTheta);","shadowValue = ( ","texture2DShadowLerp( shadowMap, shadowMapResolution, shadowCoordNDC.xy + randomRotationMatrix * vec2( dx0, dy0 ), shadowCoordNDC.z ) + ","texture2DShadowLerp( shadowMap, shadowMapResolution, shadowCoordNDC.xy + randomRotationMatrix * vec2( 0.0, dy0 ), shadowCoordNDC.z ) + ","texture2DShadowLerp( shadowMap, shadowMapResolution, shadowCoordNDC.xy + randomRotationMatrix * vec2( dx1, dy0 ), shadowCoordNDC.z ) + ","texture2DShadowLerp( shadowMap, shadowMapResolution, shadowCoordNDC.xy + randomRotationMatrix * vec2( dx0, 0.0 ), shadowCoordNDC.z ) + ","texture2DShadowLerp( shadowMap, shadowMapResolution, shadowCoordNDC.xy, shadowCoordNDC.z ) + ","texture2DShadowLerp( shadowMap, shadowMapResolution, shadowCoordNDC.xy + randomRotationMatrix * vec2( dx1, 0.0 ), shadowCoordNDC.z ) +","texture2DShadowLerp( shadowMap, shadowMapResolution, shadowCoordNDC.xy + randomRotationMatrix * vec2( dx0, dy1 ), shadowCoordNDC.z ) +","texture2DShadowLerp( shadowMap, shadowMapResolution, shadowCoordNDC.xy + randomRotationMatrix * vec2( 0.0, dy1 ), shadowCoordNDC.z ) +","texture2DShadowLerp( shadowMap, shadowMapResolution, shadowCoordNDC.xy + randomRotationMatrix * vec2( dx1, dy1 ), shadowCoordNDC.z )",") * ( 1.0 / 9.0 );","#endif","}","float previousAccumulation = unpackRGBAToDepth(texture2D( shadowAccumulationBuffer, gl_FragCoord.xy/shadowBufferSize ));","float t = shadowData.w/shadowData.x;","float shadowAccumulation = mix(previousAccumulation, shadowValue, t);","gl_FragColor = packDepthToRGBA(shadowAccumulation);","}"].join("\n")}},function(e,t,i){i(0),i(2),i(23),i(24),e.exports=PIXOTRON.PlaneShadowBakePass=class{constructor(e){e=e||{},this.linearDepth=void 0!==e.linearDepth?e.linearDepth:1,this.shadowMapResolution=void 0!==e.shadowMapResolution?e.shadowMapResolution:1024,this.shadowRadius=void 0!==e.shadowRadius?e.shadowRadius:1,this.shadowQuality=void 0!==e.shadowQuality?e.shadowQuality:1,this.smoothTransition=void 0===e.smoothTransition||e.smoothTransition,this.shadowBiasMultiplier=void 0!==e.shadowBiasMultiplier?e.shadowBiasMultiplier:1,this.numSamples=void 0!==e.numSamples?e.numSamples:2e3,this.numSamplesPerFrame=void 0!==e.numSamplesPerFrame?e.numSamplesPerFrame:2,this.darkness=void 0!==e.darkness?e.darkness:1,this.falloff=void 0!==e.falloff?e.falloff:2,this.size=void 0!==e.size?e.size:1,this.lightDirection=e.lightDirection?e.lightDirection:new THREE.Vector3(0,1,0),this.lightSolidAngle=e.lightSolidAngle?e.lightSolidAngle:45,this.onComplete=e.onComplete,this.onProgress=e.onProgress,this.enable=void 0===e.enable||e.enable,this.oi=void 0===e.enableBlur||e.enableBlur;const t=void 0===e.bShadowMaterial||e.bShadowMaterial,i=void 0!==e.nearPlane?e.nearPlane:.1,s=void 0!==e.farPlane?e.farPlane:10;this.Ve=new THREE.OrthographicCamera(-3,3,3,-3,i,s),this.boundingRadius=10,this.ge=0,this.Le(this.numSamples),this.C=0,this.ke=new THREE.Vector3,this.We=new THREE.Vector3(0,-1,0),this.je=new THREE.Vector3,this.Ze=new THREE.Matrix4,this.needsUpdate=!0,this.ai=new THREE.Mesh(new THREE.PlaneBufferGeometry(1,1),new THREE.MeshBasicMaterial({color:16777215})),this.ai.rotation.x=-Math.PI/2,this.ai.receiveShadow=!0,this.ni=new THREE.Scene,this.ni.add(this.ai);const a=t?new THREE.MeshBasicMaterial({color:16777215,transparent:!0}):new THREE.MeshStandardMaterial({roughness:1,metalness:0});this.hi=new THREE.Mesh(new THREE.PlaneBufferGeometry(1,1),a);const r=this.hi.geometry.attributes.uv.array;this.hi.geometry.addAttribute("uv2",new THREE.BufferAttribute(r,2)),this.hi.rotation.x=-Math.PI/2,this.hi.receiveShadow=!0}convergenceMetric(){return this.C/this.Ge.length}dispose(){this.Qe.dispose(),this.qe.dispose(),this.Ke.dispose(),this.hi.geometry.dispose()}getShadowPlane(){return this.hi}ri(e){e.updateMatrixWorld(),this.li=new THREE.Box3,e.traverse(e=>{e.isMesh&&e.castShadow&&this.li.expandByObject(e)});const t=new THREE.Sphere;this.li.getBoundingSphere(t);const i=2.5*t.radius*this.size;if(0===i)return;this.ai.scale.set(i,i,i);const s=new THREE.Vector3;this.li.getCenter(s),this.ai.position.set(s.x,this.li.min.y,s.z),this.hi.position.set(s.x,this.li.min.y,s.z),this.hi.scale.copy(this.ai.scale),this.boundingRadius=2*t.radius,this.Ve.left=-t.radius,this.Ve.right=t.radius,this.Ve.bottom=-t.radius,this.Ve.top=t.radius,this.Ve.far=this.boundingRadius+10,this.Ve.updateProjectionMatrix(),this.needsUpdate=!0}startBake(e,t,i){this.ci&&cancelAnimationFrame(this.ci),this.needsUpdate=!0;const s=()=>{this.ui(e,t,i),this.ci=requestAnimationFrame(s),this.convergenceMetric()>=1&&(this.onComplete&&this.onComplete(this.hi),cancelAnimationFrame(this.ci))};this.ci=requestAnimationFrame(s)}ui(e,t,i){if(!this.enable)return;if(this.needsUpdate&&(this.ri(t),this.C=0,this.needsUpdate=!1),this.onProgress){const e=this.convergenceMetric();this.onProgress(e)}this.Qe||(this.Ve.layers.mask=i.layers.mask,this.$e()),this.Le(this.numSamples);const s=e.getClearColor(),a=e.getClearAlpha(),r=e.autoClear;let o,n;for(let s=0;s<this.numSamplesPerFrame;s++)this.C=Math.min(this.C,this.Ge.length-1),this.C++,this.di(),this.ii(e,t,this.ke,this.Qe),o=this.C%2==0?this.qe:this.Ke,n=this.C%2==0?this.Ke:this.qe,this.si(e,t,i,o,n);this.oi&&this.vi(e,n,o),this.Me.uniforms.shadowAccumulationBuffer.value=n,this.Me.uniforms.transition.value=this.smoothTransition?this.convergenceMetric():1;const l=this.Me.uniforms.shadowData.value;l.x=this.hi.material.isMeshBasicMaterial?1-this.darkness:this.darkness,l.y=this.falloff,PIXOTRON.renderPass(e,this.Me,o),e.autoClear=r,e.setClearColor(s),e.setClearAlpha(a),this.hi.material.isMeshBasicMaterial?this.hi.material.map=o.texture:this.hi.material.aoMap=o.texture}setSize(e,t){this.qe&&this.qe.setSize(e,t),this.Ke&&this.Ke.setSize(e,t),this.Qe&&this.Qe.setSize(e,t),this.Ye.uniforms.shadowBufferSize.value.set(e,t)}vi(e,t,i){this.mi||(this.mi=new THREE.ShaderMaterial(PIXOTRON.BlurShader)),this.mi.uniforms.tDiffuse.value=t,this.mi.uniforms.direction.value=new THREE.Vector3(1,0),this.mi.uniforms.size.value.x=i.width,this.mi.uniforms.size.value.y=i.height,PIXOTRON.renderPass(e,this.mi,i),this.mi.uniforms.tDiffuse.value=i,this.mi.uniforms.direction.value=new THREE.Vector3(0,1),this.mi.uniforms.size.value.x=i.width,this.mi.uniforms.size.value.y=i.height,PIXOTRON.renderPass(e,this.mi,t)}$e(){const e={format:THREE.RGBAFormat,minFilter:THREE.LinearFilter,magFilter:THREE.LinearFilter};this.Qe=new THREE.WebGLRenderTarget(this.shadowMapResolution,this.shadowMapResolution,e),this.qe=new THREE.WebGLRenderTarget(this.shadowMapResolution,this.shadowMapResolution,e),this.Ke=new THREE.WebGLRenderTarget(this.shadowMapResolution,this.shadowMapResolution,e),this.Qe.texture.generateMipmaps=!1,this.qe.texture.generateMipmaps=!1,this.Ke.texture.generateMipmaps=!1,this.linearDepth?(this.Ee=new THREE.ShaderMaterial(PIXOTRON.PackingShader_Depth32),this.Ee.uniforms=THREE.UniformsUtils.clone(this.Ee.uniforms)):this.Ee=new THREE.MeshDepthMaterial({depthPacking:THREE.RGBADepthPacking}),this.Ye=new THREE.ShaderMaterial(PIXOTRON.SoftShadowPlaneShader),this.Ye.uniforms=THREE.UniformsUtils.clone(this.Ye.uniforms),this.Ye.uniforms.shadowBufferSize.value=new THREE.Vector2(this.shadowMapResolution,this.shadowMapResolution),this.Ye.uniforms.shadowMap.value=this.Qe,this.Ye.uniforms.shadowData.value=new THREE.Vector4(0,1,1,1),this.Ye.uniforms.shadowMapResolution.value=new THREE.Vector2(this.shadowMapResolution,this.shadowMapResolution),this.Ye.defines.SHADOW_QUALITY=this.shadowQuality,this.Ye.defines.LINEAR_DEPTH=this.linearDepth,this.Me=new THREE.ShaderMaterial(PIXOTRON.SmoothTransitionSoftShadowShadowShader),this.Me.defines.SHADOW_MATERIAL=this.hi.material.isMeshBasicMaterial?1:0,this.Me.uniforms=THREE.UniformsUtils.clone(this.Me.uniforms)}si(e,t,i,s,a){this.Ve.matrixWorldInverse.getInverse(this.Ve.matrixWorld),this.Ze.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),this.Ze.multiply(this.Ve.projectionMatrix),this.Ze.multiply(this.Ve.matrixWorldInverse),this.Ye.uniforms.shadowMatrix.value.copy(this.Ze),this.Ye.uniforms.shadowData.value.x=this.C,this.Ye.uniforms.shadowData.value.y=this.shadowRadius,this.Ye.uniforms.shadowData.value.z=this.shadowBiasMultiplier,this.Ye.uniforms.shadowAccumulationBuffer.value=s,this.Ye.uniforms.vplPosition.value=this.Ve.position,this.Ye.uniforms.cameraNearFar.value.x=this.Ve.near,this.Ye.uniforms.cameraNearFar.value.y=this.Ve.far,this.Ye.uniforms.lightVector.value.x=-this.We.x,this.Ye.uniforms.lightVector.value.y=-this.We.y,this.Ye.uniforms.lightVector.value.z=-this.We.z,this.Ye.uniforms.weightSum.value=1/this.Ge.length,e.setClearColor(0);const r=e.shadowMap.enabled;e.shadowMap.enabled=!1,this.ni.overrideMaterial=this.Ye,e.setRenderTarget(a),e.clear(!0,!0,!1),e.render(this.ni,i),e.setRenderTarget(null),this.ni.overrideMaterial=null,e.shadowMap.enabled=r}ii(e,t,i,s){!function(e,t){e.traverse((function(e){(e.isMesh||e.isLineSegments||e.isLine||e.isLineLoop||e.isPoints)&&(e.castShadow||(e.oldVisibility=e.visible,e.visible=!1))}))}(t),this.Ve.position.copy(i),this.je.copy(i),this.je.addScaledVector(this.We,10),this.Ve.lookAt(this.je),this.Ve.updateMatrixWorld(),t.overrideMaterial=this.Ee,this.linearDepth&&(this.Ee.uniforms.cameraNearFar.value.x=this.Ve.near,this.Ee.uniforms.cameraNearFar.value.y=this.Ve.far),e.setClearColor(0),e.setRenderTarget(s),e.clear(!0,!0,!1),e.render(t,this.Ve),e.setRenderTarget(null),t.overrideMaterial=null,function(e){e.traverse((function(e){e.oldVisibility&&(e.visible=e.oldVisibility,e.oldVisibility=void 0)}))}(t)}sampleUniformCone(e,t,i){const s=1-e.x+e.x*t,a=Math.sqrt(1-s*s),r=2*e.y*Math.PI;i.x=Math.cos(r)*a,i.y=Math.sin(r)*a,i.z=s}di(){const e=this.boundingRadius,t=this.Ge[this.C-1];let i=this.lightSolidAngle>45?45:this.lightSolidAngle;i=this.lightSolidAngle<0?0:i;const s=Math.cos(i*Math.PI/180);this.sampleUniformCone(t,s,this.We),this.We.multiplyScalar(-1),this.We.normalize();const a=new THREE.Matrix4;this.lightDirection.normalize(),a.lookAt(this.lightDirection,new THREE.Vector3(0,0,0),new THREE.Vector3(0,1,0)),this.We.transformDirection(a),this.We.normalize();const r=new THREE.Vector3(-e*this.We.x,-e*this.We.y,-e*this.We.z);this.ke.copy(r),this.ke.add(this.ai.position)}Le(e){e!==this.ge&&(this.ge=e,this.Ge=PIXOTRON.generateQuasiRandomPoints(e,-1,PIXOTRON.uniformDistribution,PIXOTRON.insideRectngle),this.Ge=PIXOTRON.randomizeArray(this.Ge))}}},function(e,t){e.exports=PIXOTRON.SoftShadowPlaneShader={defines:{SHADOW_QUALITY:0,LINEAR_DEPTH:1},uniforms:{shadowMap:{value:null},shadowAccumulationBuffer:{value:null},shadowBufferSize:{value:null},shadowMatrix:{value:new THREE.Matrix4},vplPosition:{value:new THREE.Vector3},lightVector:{value:new THREE.Vector3},shadowData:{value:new THREE.Vector4},cameraNearFar:{value:new THREE.Vector2},shadowMapResolution:{value:null},normalBias:{value:1},weightSum:{value:0}},vertexShader:["varying vec3 viewNormal;","varying vec4 shadowCoord;","uniform vec3 vplPosition;","uniform mat4 shadowMatrix;","uniform float normalBias;","void main() {","vec4 worldPosition = modelMatrix * vec4( position, 1.0 );","viewNormal = normalize(normalMatrix * normal);","vec3 vplPositionEyeSpace = (viewMatrix * vec4(vplPosition, 1.0)).xyz;","//lightVector = vplPositionEyeSpace - (modelViewMatrix * vec4( position, 1.0 )).xyz;","//lightVector = normalize(lightVector);","shadowCoord = shadowMatrix * worldPosition;","// nDotL = clamp( dot(lightVector, viewNormal), 0.0, 1.0);","//worldPosition.xyz += normalize((modelMatrix * vec4( normal, 0.0 )).xyz) * 0.02 * normalBias * pow( 1.0 -  nDotL * nDotL, 4.);","//shadowCoord.xy = (shadowMatrix * worldPosition).xy;","//gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","gl_Position = vec4( 2. * uv.x - 1., 2. * uv.y - 1., 0., 1.0 );","}"].join("\n"),fragmentShader:["#include <common>","#include <packing>","varying vec3 viewNormal;","uniform vec3 lightVector;","varying vec4 shadowCoord;","uniform vec2 shadowBufferSize;","uniform vec2 shadowMapResolution;","uniform sampler2D shadowMap;","uniform sampler2D shadowAccumulationBuffer;","uniform vec4 shadowData;","uniform vec2 cameraNearFar;","uniform float weightSum;","float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {","#if LINEAR_DEPTH == 0","float shadowDepth = unpackRGBAToDepth( texture2D( depths, uv ) );","#else","float shadowDepth = pow2(unpackRGBAToDepth(texture2D( depths, uv ))) + 0.01 * shadowData.z;","shadowDepth = shadowDepth * ( cameraNearFar.y - cameraNearFar.x ) + cameraNearFar.x;","#endif","return step( compare, shadowDepth );","}","float texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {","const vec2 offset = vec2( 0.0, 1.0 );","vec2 texelSize = vec2( 1.0 ) / size;","vec2 centroidUV = floor( uv * size + 0.5 ) / size;","float lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );","float lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );","float rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );","float rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );","vec2 f = fract( uv * size + 0.5 );","float a = mix( lb, lt, f.y );","float b = mix( rb, rt, f.y );","float c = mix( a, b, f.x );","return c;","}","void main() {","float shadowValue = 1.0;","float shadowRadius = shadowData.y;","float shadowBiasMultiplier = shadowData.z;","float nDotL = clamp( dot(lightVector, normalize(viewNormal)), 0.0, 1.0);","float shadowBias = 0.02 *  sqrt( 1.0 -  nDotL * nDotL) / clamp(nDotL, 0.0006,  1.0);","shadowBias = clamp(shadowBias, 0.0001,  0.0003) * shadowBiasMultiplier;","vec3 shadowCoordNDC = shadowCoord.xyz;///shadowCoord.w;","shadowCoordNDC.z -= shadowBias;","#if LINEAR_DEPTH == 1","float linearDepth = shadowCoord.z + (cameraNearFar.y + cameraNearFar.x)/(cameraNearFar.y - cameraNearFar.x);","linearDepth *= -(cameraNearFar.y - cameraNearFar.x) * 0.5;","linearDepth = -linearDepth;","#endif","bvec4 inFrustumVec = bvec4 ( shadowCoordNDC.x >= 0.0, shadowCoordNDC.x <= 1.0, shadowCoordNDC.y >= 0.0, shadowCoordNDC.y <= 1.0 );","bool inFrustum = all( inFrustumVec );","bvec2 frustumTestVec = bvec2( inFrustum, shadowCoordNDC.z <= 1.0 );","bool frustumTest = all( frustumTestVec );","#if LINEAR_DEPTH == 1","shadowCoordNDC.z = linearDepth;","#endif","if(frustumTest) {","#if SHADOW_QUALITY == 0","shadowValue = texture2DCompare(shadowMap, shadowCoordNDC.xy, shadowCoordNDC.z);","#elif SHADOW_QUALITY == 1","vec2 texelSize = vec2( 1.0 ) / shadowMapResolution;","float dx0 = - texelSize.x * shadowRadius;","float dy0 = - texelSize.y * shadowRadius;","float dx1 = + texelSize.x * shadowRadius;","float dy1 = + texelSize.y * shadowRadius;","float theta = rand( shadowCoord.xy ) * PI2;","float snTheta = sin(theta);","float csTheta = cos(theta);","mat2 randomRotationMatrix = mat2(csTheta, snTheta, -snTheta, csTheta);","shadowValue = (","texture2DCompare( shadowMap, shadowCoordNDC.xy + randomRotationMatrix * vec2( dx0, dy0 ), shadowCoordNDC.z ) + ","texture2DCompare( shadowMap, shadowCoordNDC.xy + randomRotationMatrix * vec2( 0.0, dy0 ), shadowCoordNDC.z ) + ","texture2DCompare( shadowMap, shadowCoordNDC.xy + randomRotationMatrix * vec2( dx1, dy0 ), shadowCoordNDC.z ) + ","texture2DCompare( shadowMap, shadowCoordNDC.xy + randomRotationMatrix * vec2( dx0, 0.0 ), shadowCoordNDC.z ) + ","texture2DCompare( shadowMap, shadowCoordNDC.xy, shadowCoordNDC.z ) + ","texture2DCompare( shadowMap, shadowCoordNDC.xy + randomRotationMatrix * vec2( dx1, 0.0 ), shadowCoordNDC.z ) + ","texture2DCompare( shadowMap, shadowCoordNDC.xy + randomRotationMatrix * vec2( dx0, dy1 ), shadowCoordNDC.z ) + ","texture2DCompare( shadowMap, shadowCoordNDC.xy + randomRotationMatrix * vec2( 0.0, dy1 ), shadowCoordNDC.z ) + ","texture2DCompare( shadowMap, shadowCoordNDC.xy + randomRotationMatrix * vec2( dx1, dy1 ), shadowCoordNDC.z )",") * ( 1.0 / 9.0 );","#elif SHADOW_QUALITY == 2","vec2 texelSize = vec2( 1.0 ) / shadowMapResolution;","float dx0 = - texelSize.x * shadowRadius;","float dy0 = - texelSize.y * shadowRadius;","float dx1 = + texelSize.x * shadowRadius;","float dy1 = + texelSize.y * shadowRadius;","float theta = rand( shadowCoord.xy ) * PI2;","float snTheta = sin(theta);","float csTheta = cos(theta);","mat2 randomRotationMatrix = mat2(csTheta, snTheta, -snTheta, csTheta);","shadowValue = ( ","texture2DShadowLerp( shadowMap, shadowMapResolution, shadowCoordNDC.xy + randomRotationMatrix * vec2( dx0, dy0 ), shadowCoordNDC.z ) + ","texture2DShadowLerp( shadowMap, shadowMapResolution, shadowCoordNDC.xy + randomRotationMatrix * vec2( 0.0, dy0 ), shadowCoordNDC.z ) + ","texture2DShadowLerp( shadowMap, shadowMapResolution, shadowCoordNDC.xy + randomRotationMatrix * vec2( dx1, dy0 ), shadowCoordNDC.z ) + ","texture2DShadowLerp( shadowMap, shadowMapResolution, shadowCoordNDC.xy + randomRotationMatrix * vec2( dx0, 0.0 ), shadowCoordNDC.z ) + ","texture2DShadowLerp( shadowMap, shadowMapResolution, shadowCoordNDC.xy, shadowCoordNDC.z ) + ","texture2DShadowLerp( shadowMap, shadowMapResolution, shadowCoordNDC.xy + randomRotationMatrix * vec2( dx1, 0.0 ), shadowCoordNDC.z ) +","texture2DShadowLerp( shadowMap, shadowMapResolution, shadowCoordNDC.xy + randomRotationMatrix * vec2( dx0, dy1 ), shadowCoordNDC.z ) +","texture2DShadowLerp( shadowMap, shadowMapResolution, shadowCoordNDC.xy + randomRotationMatrix * vec2( 0.0, dy1 ), shadowCoordNDC.z ) +","texture2DShadowLerp( shadowMap, shadowMapResolution, shadowCoordNDC.xy + randomRotationMatrix * vec2( dx1, dy1 ), shadowCoordNDC.z )",") * ( 1.0 / 9.0 );","#endif","}","float previousAccumulation = unpackRGBAToDepth(texture2D( shadowAccumulationBuffer, gl_FragCoord.xy/shadowBufferSize ));","if(shadowData.x == 1.) {","previousAccumulation = 0.;","}","float shadowAccumulation = previousAccumulation + shadowValue * weightSum;//mix(previousAccumulation, shadowValue, 1./shadowData.x);","gl_FragColor = packDepthToRGBA(shadowAccumulation);","}"].join("\n")}},function(e,t){e.exports=PIXOTRON.BlurShader={uniforms:{tDiffuse:{value:null},size:{value:new THREE.Vector3},direction:{value:new THREE.Vector3(1,0)},step:{value:.5}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;","gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["#include <packing>","uniform sampler2D tDiffuse;","uniform vec2 size;","uniform vec2 direction;","uniform float step;","varying vec2 vUv;","void main() {","float sum = 0.0;","vec2 uvDelta = step * direction / size;","//sum += texture2D( tDiffuse, vUv - 3. * uvDelta ) * 0.0918;","//sum += texture2D( tDiffuse, vUv - 2. * uvDelta ) * 0.2;","sum += unpackRGBAToDepth(texture2D( tDiffuse, vUv - 1. * uvDelta )) * 0.3333;","sum += unpackRGBAToDepth(texture2D( tDiffuse, vec2( vUv.x, vUv.y ) )) * 0.3333;","sum += unpackRGBAToDepth(texture2D( tDiffuse, vUv + 1. * uvDelta )) * 0.3333;","//sum += texture2D( tDiffuse, vUv + 2. * uvDelta ) * 0.2;","//sum += texture2D( tDiffuse, vUv + 3. * uvDelta ) * 0.0918;","gl_FragColor = packDepthToRGBA(sum);//texture2D( tDiffuse, vec2( vUv.x, vUv.y ) );","}"].join("\n")}},function(e,t,i){PIXOTRON.SuperSampleAAShader={uniforms:{tCurrent:{type:"t",value:null},tSumPrevious:{type:"t",value:null},accIndex:{type:"f",value:0}},vertexShader:"varying vec2 vUv;    void main() {      vUv = uv;      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );    }",fragmentShader:"varying vec2 vUv;    uniform sampler2D tCurrent;    uniform sampler2D tSumPrevious;    uniform float accIndex;    void main() {      vec4 currentColor = texture2D(tCurrent, vUv);      vec4 previousSum = texture2D(tSumPrevious, vUv);      gl_FragColor = mix(previousSum, currentColor, 1./accIndex);    }    "}},function(e,t,i){i(27);const s=new THREE.Vector2;e.exports=PIXOTRON.TemporalAAPass=class extends THREE.Pass{constructor(e,t){super(),this.feedBack=new THREE.Vector2(.8,.9),this.G=e,this.F=t,this.fi=new THREE.ShaderMaterial(PIXOTRON.TemporalAAShader),this.pi=new THREE.Matrix4,this.Ei=new THREE.Matrix4,this.ct=new THREE.Matrix4,this.ct.copy(this.G.projectionMatrix)}dispose(){this.wi&&(this.wi.dispose(),this.fi.dispose())}setSize(e,t){this.wi&&this.wi.setSize(e,t),this.ct.copy(this.G.projectionMatrix)}render(e,t,i){this.X(e);const s=e.getClearColor(),a=e.getClearAlpha(),r=e.autoClear;e.autoClear=!1,e.setClearColor(new THREE.Color(0,0,0),0),this.Ei.multiplyMatrices(this.ct,this.G.matrixWorldInverse),this.Ri(e,i),PIXOTRON.renderPass(e,this.fi,t),PIXOTRON.blit(e,t.texture,this.wi),e.setClearColor(s,a),e.autoClear=r,this.pi.copy(this.Ei)}X(e){e.getDrawingBufferSize(s);const t=s.x,i=s.y;if(!this.wi){const e={minFilter:THREE.LinearFilter,magFilter:THREE.LinearFilter,format:THREE.RGBAFormat};this.wi=new THREE.WebGLRenderTarget(t,i,e)}}Ri(e,t){let i,a;i=this.F.Dt?this.F.Dt:this.F.Re?this.F.Re.texture:null,this.F.Re||(a=this.F.we?this.F.we.texture:null),this.fi.uniforms.currentRT.value=t.texture,this.fi.uniforms.previousRT.value=this.wi.texture,this.fi.uniforms.tDepth.value=i||a;let r=this.F.Dt?0:1;this.F.forceDepthAndNormalPass&&this.F.packingMode===PIXOTRON.GBufferPass.DEPTH_NORMAL_16&&(r=2),this.fi.defines.DEPTH_PACKING_MODE=r,this.fi.uniforms.currentProjectionViewMatrix.value.copy(this.Ei),this.fi.uniforms.lastProjectionViewMatrix.value.copy(this.pi),this.fi.uniforms.ProjectionMatrix.value.copy(this.ct),this.fi.uniforms.InverseViewMatrix.value.copy(this.G.matrixWorld),this.fi.uniforms.feedBack.value.x=this.feedBack.x,this.fi.uniforms.feedBack.value.y=this.feedBack.y;const o=this.fi.uniforms.cameraNearFar.value;o.x=this.G.near,o.y=this.G.far,e.getDrawingBufferSize(s);const n=s.x,l=s.y,h=this.fi.uniforms.textureSize.value;h.x=n,h.y=l,this.fi.defines.LINEAR_DEPTH=this.F.pe?1:0}}},function(e,t){e.exports=PIXOTRON.TemporalAAShader={defines:{DEPTH_PACKING_MODE:1,PERSPECTIVE_CAMERA:1,LINEAR_DEPTH:1,QUALITY:1,UNJITTER:0},uniforms:{currentRT:{value:null},previousRT:{value:null},tDepth:{value:null},cameraNearFar:{value:new THREE.Vector2},textureSize:{value:new THREE.Vector2},lastProjectionViewMatrix:{value:new THREE.Matrix4},currentProjectionViewMatrix:{value:new THREE.Matrix4},ProjectionMatrix:{value:new THREE.Matrix4},InverseViewMatrix:{value:new THREE.Matrix4},jitterSample:{value:new THREE.Vector2},feedBack:{value:new THREE.Vector2(.88,.97)}},vertexShader:"varying vec2 vUv;        void main() {          vUv = uv;          gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );        }",fragmentShader:["#include <common>","varying vec2 vUv;","uniform sampler2D currentRT;","uniform sampler2D previousRT;","uniform sampler2D tDepth;","uniform vec2 textureSize;","uniform mat4 lastProjectionViewMatrix;","uniform mat4 currentProjectionViewMatrix;","uniform mat4 ProjectionMatrix;","uniform mat4 InverseViewMatrix;","uniform vec2 cameraNearFar;","uniform vec2 jitterSample;","uniform vec2 feedBack;","#include <packing>","float unpack16(vec2 value) {","return (","value.x*0.996108949416342426275150501169264316558837890625 +","value.y*0.00389105058365758760263730664519243873655796051025390625",");","}","float decodeDepth( const in vec2 uv ) {","#if DEPTH_PACKING_MODE == 1","#if LINEAR_DEPTH == 0","return unpackRGBAToDepth( texture2D( tDepth, uv ) );","#else","return pow2(unpackRGBAToDepth(texture2D( tDepth, uv )));","#endif","#elif DEPTH_PACKING_MODE == 2","#if LINEAR_DEPTH == 1","return pow2(unpack16(texture2D( tDepth, uv ).xy));","#else","return pow2(unpack16( texture2D( tDepth, uv ).xy ));","#endif","#else","return texture2D( tDepth, uv ).x;","#endif","}","float getViewZ( const in float depth ) {","\t#if PERSPECTIVE_CAMERA == 1","\treturn perspectiveDepthToViewZ( depth, cameraNearFar.x, cameraNearFar.y );","\t#else","\treturn orthoDepthToViewZ( depth, cameraNearFar.x, cameraNearFar.y );","\t#endif","}","vec3 find_closest_fragment_3x3(const in vec2 uv) { ","const vec3 offset = vec3(-1.0, 1.0, 0.0);","vec2 texelSize = 1.0/textureSize; ","vec3 dtr = vec3(-1, 1, decodeDepth( uv + offset.yx * texelSize) ); ","vec3 dtc = vec3( 0, 1, decodeDepth( uv + offset.zx * texelSize) );","vec3 dtl = vec3( 1, 1, decodeDepth( uv + offset.xx * texelSize) );","vec3 dml = vec3(-1, 0, decodeDepth( uv + offset.yz * texelSize) );","vec3 dmc = vec3( 0, 0, decodeDepth( uv ) );","vec3 dmr = vec3( 1, 0, decodeDepth( uv + offset.xz * texelSize) );","vec3 dbl = vec3(-1, -1, decodeDepth( uv + offset.yy * texelSize) );","vec3 dbc = vec3( 0, -1, decodeDepth( uv + offset.zy * texelSize) );","vec3 dbr = vec3( 1, -1, decodeDepth( uv + offset.xy * texelSize) );","vec3 dmin = dtl;","if ( dmin.z > dtc.z ) dmin = dtc;","if ( dmin.z > dtr.z ) dmin = dtr;","if ( dmin.z > dml.z ) dmin = dml;","if ( dmin.z > dmc.z ) dmin = dmc;","if ( dmin.z > dmr.z ) dmin = dmr;","if ( dmin.z > dbl.z ) dmin = dbl;","if ( dmin.z > dbc.z ) dmin = dbc;","if ( dmin.z > dbr.z ) dmin = dbr;","return vec3(uv + texelSize.xy * dmin.xy, dmin.z);","}","vec3 find_closest_fragment_5tap(const in vec2 uv) ","{ ","vec2 texelSize = 1.0/textureSize; ","vec2 offset = vec2(1.0, -1.0);","vec3 dtl = vec3(-1, 1, decodeDepth( uv + offset.yx * texelSize) ); ","vec3 dtr = vec3( 1, 1, decodeDepth( uv + offset.xx * texelSize) );","vec3 dmc = vec3( 0, 0, decodeDepth( uv) );","vec3 dbl = vec3(-1, -1, decodeDepth( uv + offset.yy * texelSize) );","vec3 dbr = vec3( 1, -1, decodeDepth( uv + offset.xy * texelSize) );","vec3 dmin = dtl;","if ( dmin.z > dtr.z ) dmin = dtr;","if ( dmin.z > dmc.z ) dmin = dmc;","if ( dmin.z > dbl.z ) dmin = dbl;","if ( dmin.z > dbr.z ) dmin = dbr;","return vec3(uv + dmin.xy * texelSize, dmin.z);","}","vec4 clip_aabb(const in vec4 aabb_min, const in vec4 aabb_max, vec4 p )","{ ","const float FLT_EPS = 1e-8;","vec4 p_clip = 0.5 * (aabb_max + aabb_min); ","vec4 e_clip = 0.5 * (aabb_max - aabb_min) + FLT_EPS; ","vec4 v_clip = p - p_clip;","vec4 v_unit = abs(v_clip / e_clip);","float ma_unit = max(v_unit.x, max(v_unit.y, v_unit.z));","if (ma_unit > 1.0) ","return p_clip + v_clip / ma_unit;","else ","return p;","}","vec2 computeScreenSpaceVelocity(const in vec3 worldPosition) {","vec4 currentPositionClip = currentProjectionViewMatrix * vec4(worldPosition, 1.0);","vec4 prevPositionClip = lastProjectionViewMatrix * vec4(worldPosition, 1.0);","vec2 currentPositionNDC = currentPositionClip.xy / currentPositionClip.w;","vec2 prevPositionNDC = prevPositionClip.xy / prevPositionClip.w;","if(prevPositionNDC.x >= 1.0 || prevPositionNDC.x <= -1.0 || prevPositionNDC.x >= 1.0 || prevPositionNDC.y <= -1.0) {","return vec2(0.0);","}","return 0.5 * (currentPositionNDC - prevPositionNDC);","}","vec4 computeTAA(const in vec2 uv, const in vec2 screenSpaceVelocity) {","vec2 jitterOffset = jitterSample/textureSize;","vec2 uvUnJitter = uv;","vec4 currentColor = texture2D(currentRT, uvUnJitter);","vec4 previousColor = texture2D(previousRT, uv - screenSpaceVelocity);","const vec3 offset = vec3(1., -1., 0.);","vec2 texelSize = 1./textureSize;","float texelSpeed = length( screenSpaceVelocity );","vec4 tl = texture2D(currentRT, uvUnJitter + offset.yx * texelSize);","vec4 tc = texture2D(currentRT, uvUnJitter + offset.zx * texelSize);","vec4 tr = texture2D(currentRT, uvUnJitter + offset.xx * texelSize);","vec4 ml = texture2D(currentRT, uvUnJitter + offset.yz * texelSize);","vec4 mc = currentColor;","vec4 mr = texture2D(currentRT, uvUnJitter + offset.xz * texelSize);","vec4 bl = texture2D(currentRT, uvUnJitter + offset.yy * texelSize);","vec4 bc = texture2D(currentRT, uvUnJitter + offset.zy * texelSize);","vec4 br = texture2D(currentRT, uvUnJitter + offset.xy * texelSize);","vec4 corners = 2.0 * (tr + bl + br + tl) - 2.0 * mc;","mc += (mc - (corners * 0.166667)) * 2.718282 * 0.3;","mc = max(vec4(0.0), mc);","vec4 min5 = min(tc, min(ml, min(mc, min(mr, bc))));","vec4 max5 = max(tc, max(ml, max(mc, max(mr, bc))));","vec4 cmin = min(min5, min(tl, min(tr, min(bl, br))));","vec4 cmax = max(min5, max(tl, max(tr, max(bl, br))));;","cmin = 0.5 * (cmin + min5);","cmax = 0.5 * (cmax + max5);","previousColor = clip_aabb(cmin, cmax, previousColor);","float lum0 = linearToRelativeLuminance(currentColor.rgb);","float lum1 = linearToRelativeLuminance(previousColor.rgb);","float unbiased_diff = abs(lum0 - lum1) / max(lum0, max(lum1, 0.2));","float unbiased_weight = 1.0 - unbiased_diff;","float unbiased_weight_sqr = unbiased_weight * unbiased_weight;","float k_feedback = mix(feedBack.x, feedBack.y, unbiased_weight_sqr);","return mix(currentColor, previousColor, k_feedback);","}","vec3 getWorldPositionFromViewZ(const in vec2 uv, const in float viewDepth) {","vec2 uv_ = 2. * uv - 1.;","float xe = -(uv_.x + ProjectionMatrix[2][0]) * viewDepth/ProjectionMatrix[0][0];","float ye = -(uv_.y + ProjectionMatrix[2][1]) * viewDepth/ProjectionMatrix[1][1];","return (InverseViewMatrix * vec4(xe, ye, viewDepth, 1.)).xyz;","}","void main() {","vec2 jitterOffset = jitterSample/textureSize;","#if QUALITY == 1","vec3 c_frag = find_closest_fragment_3x3(vUv);","#else","vec3 c_frag = find_closest_fragment_5tap(vUv);","#endif","if( c_frag.z >= 0.999 ) {","gl_FragColor = texture2D(currentRT, vUv - jitterOffset);","}","else {","#if LINEAR_DEPTH == 0","float sampleViewZ = getViewZ( c_frag.z );","#else","float sampleViewZ = mix(-cameraNearFar.x, -cameraNearFar.y, c_frag.z);","#endif","vec3 worldPosition = getWorldPositionFromViewZ(c_frag.xy, sampleViewZ);","vec2 screenSpaceVelocity = computeScreenSpaceVelocity(worldPosition);","gl_FragColor = computeTAA(vUv, screenSpaceVelocity);","//gl_FragColor = vec4(10. * length(screenSpaceVelocity));","}","}"].join("\n")}},function(e,t,i){i(29);const s=new THREE.Vector2;e.exports=PIXOTRON.BilateralFilterPass=class{constructor(){this.blurKernelSize=3,this.edgeSharpness=1,this.bilateralFilterMaterial=new THREE.ShaderMaterial(PIXOTRON.SAOBilateralFilterShader),this.bilateralFilterMaterial.uniforms=THREE.UniformsUtils.clone(this.bilateralFilterMaterial.uniforms),this.bilateralFilterMaterial.defines=Object.assign({},this.bilateralFilterMaterial.defines),this.bilateralFilterMaterial.defines.USE_NORMAL_WEIGHT=1}render(e,t,i,s){this.X(e),this.Ti(e,t,i,s)}setSize(e,t){this.xi&&this.xi.setSize(e,t),this.bilateralFilterMaterial.uniforms.size.value.set(e,t)}dispose(){this.xi&&(this.xi.dispose(),this.xi=null),this.bilateralFilterMaterial.dispose()}X(e){if(!this.xi){e.getDrawingBufferSize(s);const t=s.x,i=s.y,a={minFilter:THREE.NearestFilter,magFilter:THREE.NearestFilter,format:THREE.RGBAFormat};this.xi=new THREE.WebGLRenderTarget(t,i,a)}}Ti(e,t,i,a){e.getDrawingBufferSize(s);const r=s.x,o=s.y;this.bilateralFilterMaterial.uniforms.size.value.set(r,o);const n=a.Te?a.Te.texture:null;let l;a.Re||(l=a.we?a.we.texture:null),l?(this.bilateralFilterMaterial.defines.DEPTH_NORMAL_TEXTURE=1,this.bilateralFilterMaterial.uniforms.tNormal.value=l):this.bilateralFilterMaterial.uniforms.tNormal.value=n,this.bilateralFilterMaterial.defines.KERNEL_SAMPLE_RADIUS=this.blurKernelSize,this.bilateralFilterMaterial.defines.LINEAR_DEPTH=a.pe?1:0,this.bilateralFilterMaterial.uniforms.tOcclusionDepth.value=t.texture,this.bilateralFilterMaterial.uniforms.kernelDirection.value=new THREE.Vector2(1,0),this.bilateralFilterMaterial.uniforms.edgeSharpness.value=this.edgeSharpness;const h=this.bilateralFilterMaterial.uniforms.cameraNearFar.value;h.x=i.near,h.y=i.far,PIXOTRON.renderPass(e,this.bilateralFilterMaterial,this.xi),this.bilateralFilterMaterial.uniforms.tOcclusionDepth.value=this.xi.texture,this.bilateralFilterMaterial.uniforms.kernelDirection.value=new THREE.Vector2(0,1),PIXOTRON.renderPass(e,this.bilateralFilterMaterial,t)}}},function(e,t){e.exports=PIXOTRON.SAOBilateralFilterShader={defines:{PERSPECTIVE_CAMERA:1,KERNEL_SAMPLE_RADIUS:4,LINEAR_DEPTH:1,DEPTH_NORMAL_TEXTURE:0},uniforms:{tOcclusionDepth:{type:"t",value:null},tNormal:{type:"t",value:null},size:{type:"v2",value:new THREE.Vector2(256,256)},kernelDirection:{type:"v2",value:new THREE.Vector2(1,0)},cameraNearFar:{type:"v2",value:new THREE.Vector2(1,0)},edgeSharpness:{type:"f",value:1}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;","gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["#include <common>","varying vec2 vUv;","uniform sampler2D tOcclusionDepth;","uniform sampler2D tNormal;","uniform vec2 size;","uniform vec2 cameraNearFar;","uniform float edgeSharpness;","uniform vec2 kernelDirection;","#include <packing>","float getViewZ( const in float depth ) {","#if PERSPECTIVE_CAMERA == 1","return perspectiveDepthToViewZ( depth, cameraNearFar.x, cameraNearFar.y );","#else","return orthographicDepthToViewZ( depth, cameraNearFar.x, cameraNearFar.y );","#endif","}","vec3 unpackNormal(vec2 enc) {","vec2 fenc = enc*4.0-2.0;","float f = dot(fenc,fenc);","float g = sqrt(1.0-f/4.0);","return vec3(fenc*g, 1.0-f/2.0);","}","vec3 getViewNormal( const in vec2 uv ) {","#if DEPTH_NORMAL_TEXTURE == 1","return unpackNormal( texture2D( tNormal, uv ).zw );","#else","return unpackRGBToNormal( texture2D( tNormal, uv ).xyz );","#endif","}","float linearStep(float edge0, float edge1, float value){","return clamp((value-edge0)/(edge1-edge0), 0.0, 1.0);","}","float unpackRGBToFloat(const in vec3 x) {","const vec3 decode = 1.0 / vec3(1.0, 255.0, 65025.0);","return dot(x, decode);","}","void calculateBilateralWeight( const in vec2 uv, const in vec3 centreNormal, const in float centerDepth,","const in float kernelWeight, inout float totalOcclusion, inout float totalBilateralWeight ) {","vec4 aoDepth = texture2D( tOcclusionDepth, uv );","float occlusion = aoDepth.r;","float depth = unpackRGBToFloat( aoDepth.gba );","if( depth >= ( 1.0 - EPSILON ) ) {","return;","}","vec3 normal = getViewNormal(uv);","#if LINEAR_DEPTH == 0","depth = -getViewZ( depth );","depth = linearStep(cameraNearFar.x, cameraNearFar.y, depth);","#endif","float normalWeight = 1.;","#if USE_NORMAL_WEIGHT == 1","float normalCloseness = dot(normal, centreNormal);","normalCloseness *= normalCloseness;","float normalError = (1.0 - normalCloseness) * 8.;","normalWeight = max((1.0 - normalError * edgeSharpness), 0.00);","#endif","float depthWeight = max(0.0, 1.0 - edgeSharpness * 4000. * abs(depth - centerDepth)) * kernelWeight;","float bilateralWeight = depthWeight * normalWeight;","totalOcclusion += occlusion * bilateralWeight;","totalBilateralWeight += bilateralWeight;","}","void main() {","vec4 aoDepth = texture2D( tOcclusionDepth, vUv );","float occlusion = aoDepth.r;","float depth = unpackRGBToFloat( aoDepth.gba );","if( depth >= ( 1.0 - EPSILON ) ) {","discard;","}","vec3 centreNormal = getViewNormal(vUv);","#if LINEAR_DEPTH == 0","float centerViewZ = -getViewZ( depth );","centerViewZ = linearStep(cameraNearFar.x, cameraNearFar.y, centerViewZ);","#else","float centerViewZ = depth;","#endif","float gaussianWeights[4];","gaussianWeights[0] = 0.153170;","gaussianWeights[1] = 0.144893;","gaussianWeights[2] = 0.122649;","gaussianWeights[3] = 0.092902;","float totalBilateralWeight = gaussianWeights[0] + 0.03;","float totalOcclusion = occlusion * totalBilateralWeight;","vec2 uvDelta = 2.0 * kernelDirection / size;","float kernelWeight = gaussianWeights[1] + 0.03;","calculateBilateralWeight( vUv + uvDelta, centreNormal, centerViewZ, kernelWeight, totalOcclusion, totalBilateralWeight );","calculateBilateralWeight( vUv - uvDelta, centreNormal, centerViewZ, kernelWeight, totalOcclusion, totalBilateralWeight );","kernelWeight = gaussianWeights[2] + 0.03;","calculateBilateralWeight( vUv + 2. * uvDelta, centreNormal, centerViewZ, kernelWeight, totalOcclusion, totalBilateralWeight );","calculateBilateralWeight( vUv - 2. * uvDelta, centreNormal, centerViewZ, kernelWeight, totalOcclusion, totalBilateralWeight );","kernelWeight = gaussianWeights[3] + 0.03;","calculateBilateralWeight( vUv + 3. * uvDelta, centreNormal, centerViewZ, kernelWeight, totalOcclusion, totalBilateralWeight );","calculateBilateralWeight( vUv - 3. * uvDelta, centreNormal, centerViewZ, kernelWeight, totalOcclusion, totalBilateralWeight );","occlusion = totalOcclusion / totalBilateralWeight;","gl_FragColor = vec4( occlusion, aoDepth.gba );","}"].join("\n")}},function(e,t,i){i(31),e.exports=PIXOTRON.UnrealBloomPass=class extends THREE.Pass{constructor(e,t,i,s,a){super(),this.F=e,this.strength=void 0!==i?i:1,this.radius=s,this.threshold=a,this.resolution=void 0!==t?new THREE.Vector2(t.x,t.y):new THREE.Vector2(256,256);const r={minFilter:THREE.LinearFilter,magFilter:THREE.LinearFilter,format:THREE.RGBAFormat};this.renderTargetsHorizontal=[],this.renderTargetsVertical=[],this.nMips=5;let o=Math.round(this.resolution.x/2),n=Math.round(this.resolution.y/2);this.renderTargetBright=new THREE.WebGLRenderTarget(o,n,r),this.renderTargetBright.texture.name="UnrealBloomPass.bright",this.renderTargetBright.texture.generateMipmaps=!1;for(let e=0;e<this.nMips;e++){let t=new THREE.WebGLRenderTarget(o,n,r);t.texture.name="UnrealBloomPass.h"+e,t.texture.generateMipmaps=!1,this.renderTargetsHorizontal.push(t),(t=new THREE.WebGLRenderTarget(o,n,r)).texture.name="UnrealBloomPass.v"+e,t.texture.generateMipmaps=!1,this.renderTargetsVertical.push(t),o=Math.round(o/2),n=Math.round(n/2)}const l=PIXOTRON.BloomExtractShader;this.bloomExtractUniforms=THREE.UniformsUtils.clone(l.uniforms),this.bloomExtractUniforms.bloomThreshold.value=a,this.materialBloomExtract=new THREE.ShaderMaterial({uniforms:this.bloomExtractUniforms,vertexShader:l.vertexShader,fragmentShader:l.fragmentShader,defines:{DEPTH_PACKING_MODE:0,LINEAR_DEPTH:1}}),this.separableBlurMaterials=[];const h=[3,5,7,9,11];o=Math.round(this.resolution.x/2),n=Math.round(this.resolution.y/2);for(let e=0;e<this.nMips;e++)this.separableBlurMaterials.push(this.getSeperableBlurMaterial(h[e])),this.separableBlurMaterials[e].uniforms.texSize.value=new THREE.Vector2(o,n),o=Math.round(o/2),n=Math.round(n/2);this.compositeMaterial=this.getCompositeMaterial(this.nMips),this.compositeMaterial.uniforms.blurTexture1.value=this.renderTargetsVertical[0].texture,this.compositeMaterial.uniforms.blurTexture2.value=this.renderTargetsVertical[1].texture,this.compositeMaterial.uniforms.blurTexture3.value=this.renderTargetsVertical[2].texture,this.compositeMaterial.uniforms.blurTexture4.value=this.renderTargetsVertical[3].texture,this.compositeMaterial.uniforms.blurTexture5.value=this.renderTargetsVertical[4].texture,this.compositeMaterial.uniforms.bloomStrength.value=i,this.compositeMaterial.uniforms.bloomRadius.value=.1,this.compositeMaterial.needsUpdate=!0,this.compositeMaterial.uniforms.bloomFactors.value=[1,.8,.6,.4,.2],this.bloomTintColors=[new THREE.Vector3(1,1,1),new THREE.Vector3(1,1,1),new THREE.Vector3(1,1,1),new THREE.Vector3(1,1,1),new THREE.Vector3(1,1,1)],this.compositeMaterial.uniforms.bloomTintColors.value=this.bloomTintColors;const u=THREE.CopyShader;this.copyUniforms=THREE.UniformsUtils.clone(u.uniforms),this.copyUniforms.opacity.value=1,this.materialCopy=new THREE.ShaderMaterial({uniforms:this.copyUniforms,vertexShader:u.vertexShader,fragmentShader:u.fragmentShader,blending:THREE.AdditiveBlending,depthTest:!1,depthWrite:!1,transparent:!0}),this.enabled=!0,this.needsSwap=!1,this.oldClearColor=new THREE.Color,this.oldClearAlpha=1,this.camera=new THREE.OrthographicCamera(-1,1,1,-1,0,1),this.scene=new THREE.Scene,this.basic=new THREE.MeshBasicMaterial,this.quad=new THREE.Mesh(new THREE.PlaneBufferGeometry(2,2),null),this.quad.frustumCulled=!1,this.scene.add(this.quad)}dispose(){for(let e=0;e<this.renderTargetsHorizontal.length;e++)this.renderTargetsHorizontal[e].dispose();for(let e=0;e<this.renderTargetsVertical.length;e++)this.renderTargetsVertical[e].dispose();this.renderTargetBright.dispose()}setSize(e,t){let i=Math.round(e/2),s=Math.round(t/2);this.renderTargetBright.setSize(i,s);for(let e=0;e<this.nMips;e++)this.renderTargetsHorizontal[e].setSize(i,s),this.renderTargetsVertical[e].setSize(i,s),this.separableBlurMaterials[e].uniforms.texSize.value=new THREE.Vector2(i,s),i=Math.round(i/2),s=Math.round(s/2)}render(e,t,i,s,a){this.oldClearColor.copy(e.getClearColor()),this.oldClearAlpha=e.getClearAlpha();const r=e.autoClear;let o,n;e.autoClear=!1,e.setClearColor(new THREE.Color(0,0,0),0),a&&e.context.disable(e.context.STENCIL_TEST),this.renderToScreen&&(this.quad.material=this.basic,this.basic.map=i.texture,e.render(this.scene,this.camera,void 0,!0)),o=this.F.Dt?this.F.Dt:this.F.Re?this.F.Re.texture:null,this.F.Re||(n=this.F.we?this.F.we.texture:null),this.materialBloomExtract.uniforms.tDepth.value=o||n;let l=this.F.Dt?0:1;this.F.forceDepthAndNormalPass&&this.F.packingMode===PIXOTRON.GBufferPass.DEPTH_NORMAL_16&&(l=2),this.materialBloomExtract.defines.DEPTH_PACKING_MODE=l,this.materialBloomExtract.defines.LINEAR_DEPTH=this.F.pe?1:0,this.bloomExtractUniforms.tColor.value=i.texture,this.bloomExtractUniforms.bloomThreshold.value=this.threshold,this.quad.material=this.materialBloomExtract,e.render(this.scene,this.camera,this.renderTargetBright,!0);let h=this.renderTargetBright;for(let t=0;t<this.nMips;t++)this.quad.material=this.separableBlurMaterials[t],this.separableBlurMaterials[t].uniforms.colorTexture.value=h.texture,this.separableBlurMaterials[t].uniforms.direction.value=PIXOTRON.UnrealBloomPass.BlurDirectionX,e.render(this.scene,this.camera,this.renderTargetsHorizontal[t],!0),this.separableBlurMaterials[t].uniforms.colorTexture.value=this.renderTargetsHorizontal[t].texture,this.separableBlurMaterials[t].uniforms.direction.value=PIXOTRON.UnrealBloomPass.BlurDirectionY,e.render(this.scene,this.camera,this.renderTargetsVertical[t],!0),h=this.renderTargetsVertical[t];this.quad.material=this.compositeMaterial,this.compositeMaterial.uniforms.bloomStrength.value=this.strength,this.compositeMaterial.uniforms.bloomRadius.value=this.radius,this.compositeMaterial.uniforms.bloomTintColors.value=this.bloomTintColors,e.render(this.scene,this.camera,this.renderTargetsHorizontal[0],!0),this.quad.material=this.materialCopy,this.copyUniforms.tDiffuse.value=this.renderTargetsHorizontal[0].texture,a&&e.context.enable(e.context.STENCIL_TEST),this.renderToScreen?e.render(this.scene,this.camera,void 0,!1):e.render(this.scene,this.camera,i,!1),e.setClearColor(this.oldClearColor,this.oldClearAlpha),e.autoClear=r}getSeperableBlurMaterial(e){return new THREE.ShaderMaterial({defines:{KERNEL_RADIUS:e,SIGMA:e},uniforms:{colorTexture:{value:null},texSize:{value:new THREE.Vector2(.5,.5)},direction:{value:new THREE.Vector2(.5,.5)}},vertexShader:"varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}",fragmentShader:"#include <common>\t\t\t\tvarying vec2 vUv;\n\t\t\t\tuniform sampler2D colorTexture;\n\t\t\t\tuniform vec2 texSize;\t\t\t\tuniform vec2 direction;\t\t\t\t\t\t\t\tfloat gaussianPdf(in float x, in float sigma) {\t\t\t\t\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\t\t\t\t}\t\t\t\tvoid main() {\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\t\t\t\t\tfloat fSigma = float(SIGMA);\t\t\t\t\tfloat weightSum = gaussianPdf(0.0, fSigma);\t\t\t\t\tvec4 diffuseSum = texture2D( colorTexture, vUv) * weightSum;\t\t\t\t\tfor( int i = 1; i < KERNEL_RADIUS; i ++ ) {\t\t\t\t\t\tfloat x = float(i);\t\t\t\t\t\tfloat w = gaussianPdf(x, fSigma);\t\t\t\t\t\tvec2 uvOffset = direction * invSize * x;\t\t\t\t\t\tvec4 sample1 = texture2D( colorTexture, vUv + uvOffset);\t\t\t\t\t\tvec4 sample2 = texture2D( colorTexture, vUv - uvOffset);\t\t\t\t\t\tdiffuseSum += (sample1 + sample2) * w;\t\t\t\t\t\tweightSum += 2.0 * w;\t\t\t\t\t}\t\t\t\t\tgl_FragColor = vec4(diffuseSum/weightSum);\n\t\t\t\t}"})}getCompositeMaterial(e){return new THREE.ShaderMaterial({defines:{NUM_MIPS:e},uniforms:{blurTexture1:{value:null},blurTexture2:{value:null},blurTexture3:{value:null},blurTexture4:{value:null},blurTexture5:{value:null},dirtTexture:{value:null},bloomStrength:{value:1},bloomFactors:{value:null},bloomTintColors:{value:null},bloomRadius:{value:0}},vertexShader:"varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}",fragmentShader:"varying vec2 vUv;\t\t\t\tuniform sampler2D blurTexture1;\t\t\t\tuniform sampler2D blurTexture2;\t\t\t\tuniform sampler2D blurTexture3;\t\t\t\tuniform sampler2D blurTexture4;\t\t\t\tuniform sampler2D blurTexture5;\t\t\t\tuniform sampler2D dirtTexture;\t\t\t\tuniform float bloomStrength;\t\t\t\tuniform float bloomRadius;\t\t\t\tuniform float bloomFactors[NUM_MIPS];\t\t\t\tuniform vec3 bloomTintColors[NUM_MIPS];\t\t\t\t\t\t\t\tfloat lerpBloomFactor(const in float factor) { \t\t\t\t\tfloat mirrorFactor = 1.2 - factor;\t\t\t\t\treturn mix(factor, mirrorFactor, bloomRadius);\t\t\t\t}\t\t\t\t\t\t\t\tvoid main() {\t\t\t\t\tgl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) + \t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) + \t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) + \t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) + \t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );\t\t\t\t}"})}},PIXOTRON.UnrealBloomPass.BlurDirectionX=new THREE.Vector2(1,0),PIXOTRON.UnrealBloomPass.BlurDirectionY=new THREE.Vector2(0,1)},function(e,t){e.exports=PIXOTRON.BloomExtractShader={uniforms:{tColor:{type:"t",value:null},tDepth:{type:"t",value:null},bloomThreshold:{type:"f",value:1}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;","gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["#include <packing>","uniform sampler2D tColor;","uniform sampler2D tDepth;","uniform float bloomThreshold;","varying vec2 vUv;","float unpack16(vec2 value){","return (","value.x*0.996108949416342426275150501169264316558837890625 +","value.y*0.00389105058365758760263730664519243873655796051025390625",");","}","float decodeDepth( const in vec2 uv ) {","vec4 uncodedDepth = texture2D( tDepth, uv );","#if DEPTH_PACKING_MODE == 0","return uncodedDepth.x;","#elif DEPTH_PACKING_MODE == 1","#if LINEAR_DEPTH == 1","return pow(unpackRGBAToDepth(uncodedDepth), 2.);","#else","return unpackRGBAToDepth(uncodedDepth );","#endif","#else","return pow(unpack16(uncodedDepth.xy), 2.);","#endif","}","void main() {","vec4 color = texture2D( tColor, vUv );","float depth = decodeDepth(vUv);","const vec3 c = vec3( 0.299, 0.587, 0.114 );","float luminance = dot( color.xyz, c );","float alpha = smoothstep( bloomThreshold, bloomThreshold + 0.01, luminance );","alpha = depth > 1. - 0.001 ? 0. : alpha;","gl_FragColor = color * alpha;","}"].join("\n")}},function(e,t){e.exports=PIXOTRON.VPLGenerationPass=class{constructor(e){this.maxVPL=e,this.Oi=0,this.Ni=PIXOTRON.generateQuasiRandomPoints(e,-1,PIXOTRON.uniformDistribution,PIXOTRON.insideRectangle),this.Di=[];for(let e=0;e<this.Ni.length;e++){const t=this.Ni[e];this.Di.push(new THREE.Vector2(t.x,t.y))}this.gi=new THREE.Ray,this.Pi=new THREE.Raycaster,this.C=0,this.Si=!1,this.Mi=[],this.Hi=new THREE.SphereBufferGeometry(.05,5,5),this.Ci=[],this.st=!1,this.needsUpdate=!0}getVPLBuffer(){return this.Ci}getNumVPL(){return this.Ni.length}generateVPLs(e,t,i,s){if(!this.st)return;if(this.needsUpdate&&(this.rt(),this.needsUpdate=!1),this.Oi>=this.getNumVPL())return this.needsUpdate=!1,void(this.yi.visible=!0);this.yi||(this.yi=new THREE.Object3D,this.yi.visible=!1,e.add(this.yi)),performance.now();let a=0;for(let r=0;r<i;r++){const o=this.gi.origin,n=this.gi.direction;if(this.Pi.set(this.gi.origin,this.gi.direction),!this._i(t,o,n,this.C*i+r))break;const l=s?s.intersectRay(this.gi,e):this.Pi.intersectObject(e,!0);if(l.length>0){const e=l[0];if(e.object instanceof THREE.Mesh){const t=new THREE.Color,i=new THREE.Vector3,s=new THREE.Vector3;i.copy(e.point),s.copy(e.face.normal),s.transformDirection(e.object.matrixWorld);const r=this.Ii(e.object.material.map,e.uv,64);t.copy(e.object.material.color),t.multiply(r),this.Ci.push({position:i,normal:s,intensity:new THREE.Vector3(t.r,t.g,t.b)}),this.Si&&this.zi(i,t),a++}}}this.C++,this.Oi+=a,this.Si&&a>0&&(performance.now(),this.Oi)}zi(e,t){const i=new THREE.MeshBasicMaterial;i.color.copy(t);const s=new THREE.Mesh(this.Hi,i);s.position.copy(e),this.yi.add(s)}rt(){this.C=0,this.Oi=0,this.Ci=[]}Ii(e,t,i){if(!e||!e.image)return new THREE.Color(16777215);let s=this.Mi[e.uuid];s||(i=i||32,s=PIXOTRON.getDataFromImage(e.image,i),this.Mi[e.uuid]=s);let a=t.x,r=t.y;void 0!==e.repeat&&(a*=e.repeat.x,r*=e.repeat.y),a*=s.width,r*=s.height,e.wrapS===THREE.RepeatWrapping&&(a%=s.width),e.wrapS===THREE.ClampToEdgeWrapping&&(a=Math.min(a,s.width-1)),e.wrapT===THREE.RepeatWrapping&&(r%=s.height),e.wrapT===THREE.ClampToEdgeWrapping&&(r=Math.min(r,s.height-1));const o=Math.floor(a),n=Math.floor(r),l=PIXOTRON.getPixelFromImageData(s,o,n);return l.r=Math.pow(l.r/255,1),l.g=Math.pow(l.g/255,1),l.b=Math.pow(l.b/255,1),new THREE.Color(l.r,l.g,l.b)}_i(e,t,i,s){if(s<this.Ni.length){const a=this.Ni[s];t.x=(2*a.x-1)*e.width*.5,t.z=0,t.y=(2*a.y-1)*e.height*.5,t.applyMatrix4(e.matrixWorld);const r=this.Di[s],o=PIXOTRON.squareToCosineHemisphere(r);return i.copy(o),i.transformDirection(e.matrixWorld),!0}return!1}}},function(e,t,i){i(34),e.exports=PIXOTRON.InstantRadiosityPass=class{constructor(){this.Xi=10,this.Ai=0,this.C=0,this.Fi=!1,this.needsUpdate=!0,this.enabled=!0}convergenceMetric(){const e=this.bi.getNumVPL();return this.enabled?this.C*this.Xi/e:1}render(e,t,i,s,a){this.needsUpdate&&(this.rt(),this.C=0,this.needsUpdate=!1),this.bi=s;const r=s.getNumVPL(),o=s.getVPLBuffer();if(0===o.length)return;if(this.convergenceMetric()>=1)return;if(!this.bbox){this.bbox=new THREE.Box3,this.bbox.setFromObject(t);const e=new THREE.Vector3;this.bbox.getSize(e),this.minDistance=Math.max(Math.max(e.x,e.y),e.z)/9}this.Ui||this.X(e),this.C++,t.overrideMaterial=this.Vi;const n=this.C%2==0?this.Ui:this.Li,l=this.C%2==0?this.Li:this.Ui;this.Vi.uniforms.accumulationBuffer.value=n.texture,this.Vi.uniforms.currentFrameCount.value=this.C,this.Bi(o,r,a),e.render(t,i,l,!0),t.overrideMaterial=null,e.indirectDiffuseBuffer=l.texture}X(e){const t=new THREE.Vector2;e.getDrawingBufferSize(t);const i=t.x,s=t.y;let a=THREE.UnsignedByteType;if(!this.Fi){const t=e.extensions,i=t.get("OES_texture_half_float");a=i?THREE.HalfFloatType:a,i||(a=t.get("OES_texture_float")?THREE.FloatType:a)}const r={type:a,format:THREE.RGBFormat,magFilter:THREE.LinearFilter,minFilter:THREE.LinearFilter};this.Ui=new THREE.WebGLRenderTarget(i,s,r),this.Ui.texture.generateMipmaps=!1,this.Li=new THREE.WebGLRenderTarget(i,s,r),this.Li.texture.generateMipmaps=!1,this.Vi=new THREE.ShaderMaterial(PIXOTRON.VPLAccumulationShader),this.Vi.defines.VPL_COUNT=this.Xi,this.Vi.uniforms.viewPort.value=new THREE.Vector2(i,s),this.Vi.uniforms.currentFrameCount.value=this.C,this.Vi.uniforms.minDistance.value=this.minDistance,(a===THREE.UnsignedByteType||this.Fi)&&(this.Vi.dithering=!0)}rt(){this.C=0,this.Ai=0}Bi(e,t,i){let s=e.length-this.Ai;s=Math.min(s,this.Xi);const a=new THREE.Vector3(0,0,0),r=[];for(let o=0;o<s;o++){const s=e[o+this.Ai];if(o>=e.length)r.push({position:a,direction:a,intensity:a});else{const e=new THREE.Vector3;e.copy(s.intensity),e.multiplyScalar(i.intensity/t),r.push({position:s.position,direction:s.normal,intensity:e})}}for(let e=0;e<this.Xi-s;e++)r.push({position:a,direction:a,intensity:a});this.Ai+=s,this.Vi.uniforms.vplLights.value=r}}},function(e,t){e.exports=PIXOTRON.VPLAccumulationShader={vertexShader:["varying vec3 worldPosition;","varying vec3 worldNormal;","void main() {","   worldPosition = (modelMatrix * vec4( position.xyz, 1.0)).xyz;","   worldNormal = (modelMatrix * vec4(normal, 0.0)).xyz;","   gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["#include <common>","#include <dithering_pars_fragment>","varying vec3 worldPosition;","varying vec3 worldNormal;","uniform vec2 viewPort;","uniform sampler2D accumulationBuffer;","uniform float currentFrameCount;","uniform float minDistance;","struct VPL {","   vec3 position;","   vec3 direction;","   vec3 intensity;","};","uniform VPL vplLights[VPL_COUNT];","float getLightIrradiance(const in vec3 lightPos, const in vec3 lightDir) {","vec3 lightVector = lightPos - worldPosition;","vec3 direction = normalize( lightVector );","float lightDistance = length( lightVector );","float distanceFalloff = 1.0 /max( lightDistance * lightDistance, minDistance * minDistance );","float csTheta_i = dot( direction, -lightDir );","float csTheta_o = dot( normalize(worldNormal), direction );","return max(csTheta_i, 0.) * max( csTheta_o, 0.0 ) * distanceFalloff / PI;","}","void main() {","vec3 colorSum = vec3(0.0);","for( int i = 0; i < VPL_COUNT; i++) {","VPL vpl = vplLights[i];","vec3 lightPosition = vpl.position;","vec3 lightDirection = vpl.direction;","vec3 lightIntensity = vpl.intensity;","vec3 lightColor = lightIntensity * getLightIrradiance( lightPosition, lightDirection );","colorSum += lightColor;","}","vec3 previousColor = texture2D( accumulationBuffer, gl_FragCoord.xy/viewPort ).rgb;","if( currentFrameCount == 1. ){","previousColor = vec3(0.);","}","vec3 newColor = previousColor + colorSum;","gl_FragColor = vec4( newColor , 1.0);","#include <dithering_fragment>","}"].join("\n"),uniforms:{vplLights:{value:null},viewPort:{value:null},accumulationBuffer:{value:null},currentFrameCount:{value:0},minDistance:{value:0}},defines:{VPL_COUNT:0}}},function(e,t,i){i(36),i(4);const s=new THREE.Vector2;e.exports=PIXOTRON.OutlinePass=class{constructor(e){e=e||{},this.highlightColor=void 0!==e.highlightColor?e.highlightColor:new THREE.Color(1,.25,0),this.edgeThickness=void 0!==e.edgeThickness?e.edgeThickness:1,this.edgeStrength=void 0!==e.edgeStrength?e.edgeStrength:1,this.transparency=void 0!==e.transparency?e.transparency:.1,this.enableAA=void 0===e.enableAA||e.enableAA,this.ki=new THREE.MeshBasicMaterial({color:this.highlightColor,side:THREE.DoubleSide}),this.C=0,this.Wi=new THREE.ShaderMaterial(PIXOTRON.EdgeDetectionShader),this.enabled=!0,this.needsUpdate=!0}pt(e,t){if(!this.enableAA)return;e.getDrawingBufferSize(s);const i=s.x,a=s.y,r=this.k[this.C%this.k.length];PIXOTRON.jitterCamera(t,r,i,a)}dispose(){this.ji.dispose(),this.Rt.dispose()}getRenderTarget(){return this.Rt}setSize(e,t){this.ji.setSize(e,t),this.Rt.setSize(e,t)}isConverged(){return this.B?this.C/this.k.length>=1:1}render(e,t,i,s){if(this.enabled&&s&&s.length>0){this.needsUpdate&&(this.rt(),this.needsUpdate=!1),this.ji||this.X(e),this.enableAA&&!this.B&&(this.B=new PIXOTRON.SuperSampleAAPass,this.k=PIXOTRON.generateQuasiRandomPoints(30,-1,PIXOTRON.uniformDistribution,PIXOTRON.insideRectangle));const a=e.getClearAlpha(),r=e.getClearColor(),o=e.autoClear;e.autoClear=!0,e.setClearColor(0,1);const n=t.background;t.background=null,this.pt(e,i),this.Zi(t,s,!1),t.overrideMaterial=this.ki,e.setRenderTarget(this.ji),e.clear(!0,!0,!1),e.render(t,i),e.setRenderTarget(null),t.overrideMaterial=null,this.Zi(t,s,!0),i.clearViewOffset(),t.background=n,0!==this.C&&this.enableAA&&(this.B.render(e,this.Rt,this.ji),PIXOTRON.blit(e,this.Rt,this.ji)),this.Wi.uniforms.maskTexture.value=this.ji.texture,this.Wi.uniforms.texSize.value.x=this.ji.width,this.Wi.uniforms.texSize.value.y=this.ji.height,this.Wi.uniforms.edgeThickness.value=this.edgeThickness,this.Wi.uniforms.highlightColor.value=this.highlightColor,this.Wi.uniforms.transparency.value=this.transparency,this.Wi.uniforms.edgeStrength.value=this.edgeStrength,PIXOTRON.renderPass(e,this.Wi,this.Rt),e.setClearColor(r,a),e.autoClear=o,this.C++}}Zi(e,t,i){const s=[];function a(e){e.isMesh&&s.push(e)}for(let e=0;e<t.length;e++)t[e].traverse(a);e.traverse((function(e){if(e.isMesh||e.isLine||e.isSprite){let t=!1;for(let i=0;i<s.length;i++)if(s[i].id===e.id){t=!0;break}if(!t){const t=e.visible;i&&!e.bVisible||(e.visible=i),e.bVisible=t}}}))}X(e){const t={minFilter:THREE.LinearFilter,magFilter:THREE.LinearFilter,format:THREE.RGBAFormat};e.getDrawingBufferSize(s);const i=s.x,a=s.y;this.ji=new THREE.WebGLRenderTarget(i,a,t),this.ji.texture.generateMipmaps=!1,this.Rt=new THREE.WebGLRenderTarget(i,a,t),this.Rt.texture.generateMipmaps=!1}rt(){this.C=0,this.B&&(this.B.needsUpdate=!0)}}},function(e,t,i){const s=i(37).default,a=i(38).default;e.exports=PIXOTRON.EdgeDetectionShader={uniforms:{maskTexture:{value:null},texSize:{value:new THREE.Vector2(.5,.5)},highlightColor:{value:new THREE.Vector3(1,1,1)},edgeThickness:{value:1},edgeStrength:{value:1},transparency:{value:.5}},vertexShader:s,fragmentShader:a}},function(e,t,i){Object.defineProperty(t,"__esModule",{value:!0}),t.default="varying vec2 vUv;\n\nvoid main() {\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}"},function(e,t,i){Object.defineProperty(t,"__esModule",{value:!0}),t.default="varying vec2 vUv;\nuniform sampler2D maskTexture;\nuniform vec2 texSize;\nuniform vec3 highlightColor;\nuniform float edgeThickness;\nuniform float edgeStrength;\nuniform float transparency;\n\nvoid main() {\n    vec2 invSize = 1.0 / texSize;\n    vec4 uvOffset = edgeThickness * vec4(1.0, 0.0, -1.0, 1.0) * vec4(invSize, invSize);\n    vec4 c = texture2D(maskTexture, vUv);\n    vec4 c1 = texture2D(maskTexture, vUv + uvOffset.xy);\n    vec4 c2 = texture2D(maskTexture, vUv - uvOffset.xy);\n    vec4 c3 = texture2D(maskTexture, vUv + uvOffset.yw);\n    vec4 c4 = texture2D(maskTexture, vUv - uvOffset.yw);\n    float diff1 = (c1.r - c2.r) * 0.5;\n    float diff2 = (c3.r - c4.r) * 0.5;\n    float d = length(vec2(diff1, diff2));\n    gl_FragColor = vec4(c.rgb, 1. - transparency) + edgeStrength * vec4(highlightColor, 1.0) * vec4(d);\n}"}]);